The i(C++17) (also referred to as i(C++1z)) standard will be implemented in
the next major version upgrade of the Gnu tt(g++) compiler (version
7.0.0 or beyond).

The working draft of the standard is freely available, and can be cloned from
the git-repository at lurl(https://github.com/cplusplus/draft.git)

In time the annotations() will reflect the changes related to the C++17
standard. Several sections in the annotations() directly relate to the C++17
standard. These sections can easily be located by looking for he C++17 entry
in the table of contents or in the index.

In addition to the topics mentioned in separate sections the C++17 standard
introduces the following features:

description(    

dit(Evaluation order of operands of operators)nl()

    Up to C++17, the evaluation order of expressions of operands of binary
operators is, except for the boolean operators tt(and) and tt(or), not
defined. C++17 changes this for postfix expressions, assignment expressions
(including compound assignments), and shift operators:
    itemization(
    it() Postfix expressions (like index operators and member selectors) 
        are evaluated from left to right;
    it() Assignment expressions are evaluated from right to left;
    it() Operands of shift operators are evaluated from left to right.
    )
    In the following examples tt(first) is evaluated before tt(second), before
tt(third), before tt(fourth), whether they are single variables, parenthesized
expressions, or function calls:
        verb(
    first.second
    fourth += third = second += first
    first << second << third << fourth
    first >> second >> third >> fourth
        )
    In addition, when overloading an operator, the function implementing the
overloaded operator is evaluated like the built-in operator it overloads, and
not in the way function calls are generally ordered.

dit([[fallthrough]])hi(fallthrough)nl()

    When statements that are nested under tt(case) entries in tt(switch)
statements continue into subsequent tt(case) or tt(default) entries the
compiler will issue a `falling through' warning. If falling through is
intentional the attribute tt([[fallthrough]]) should be used. Here is an
annotated example:
        verb(
void function(int selector)
{
    switch (selector)
    {
        case 1:
        case 2:             // no falling through, but merged entry points
            cout << "cases 1 and 2\n";
        [[fallthrough]]
        case 3:
            cout << "case 3\n";

        case 4:             // a warning is issued
            cout << "case 4\n";
        [[fallthrough]]     // error: nothing beyond
    }
}
        )

dit([[maybe_unused]])hi(maybe_unused)nl()

    This attribute can be applied to a class, typedef-name, variable,
non-static data member, a function, an enumeration or an enumerator. When it
is applied to an entity no warning is generated when the
entity is not used. Example:
        verb(
void fun([[maybe_unused]] size_t argument)
{
    // argument isn't used, but no warning 
    // telling you so is issued
}
        )

dit([[nodiscard]])hi(nodiscard)nl()

    The attribute tt([[nodiscard]]) may be specified when declaring a
function, class or enumeration. If a function is declared tt([[nodiscard]]) or
if a function returns an entity previously declared using tt([[nodiscard]])
then the return value of such a function may only be ignored when explicitly
cast to void. Otherwise, when the return value is not used a warning is
issued. Example:
        verb(
int [[nodiscard]] importantInt();
struct [[nodiscard]] ImportantStruct { ... };

ImportantStruct factory();
    
int main()
{
    importantInt();         // warning issued
    factory();              // warning issued
}
        )

COMMENT(END description))














