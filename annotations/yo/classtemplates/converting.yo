So you've decided that you want to convert some of your dynamically
polymorphic classes into statically polymorphic classes. Now what?

In chapter ref(POLYMORPHISM) the base class tt(Vehicle) and some derived
classes were introduced. tt(Vehicle, Car) and tt(Truck)'s interfaces look like
this (regarding the members that are involved in their polymorphic behaviors):
        verb(
    class Vehicle
    {
        public:
            int mass() const;

        private:
            virtual int vmass() const;
    };

    class Car: public Vehicle
    {
        private:
            int vmass() const override;
    };
        
    class Truck: public Car
    {
        private:
            int vmass() const override;
    };
        )
    )

    When converting dynamically polymorphic classes to statically polymorphic
classes we must realize that polymorphic classes show two important
characteristics:
    itemization(
    it() they define facilities (data members, member functions) that are
inherited by derived classes (e.g., tt(Vecicle::mass)) (i.e., the inheritable
interface), and
    it() derived classes implement the redefinable interface in a way that
suits their purpose (e.g., tt(Truck::vmass)).
    )

With statically polymorphic classes these two characteristics should
completely be separated.  As we've seen in the previous section, a
statically polymorphic derived class derives from its base class by using its
own class type as argument to the base class's type parameter. This works fine
if there's only one level of inheritance (i.e., one base class, and one or
more classes that are directly derived from that base class).

With multiple levels of inheritance (e.g., tt(Truck -> Car -> Vehicle))
tt(Truck)'s inheritance specification becomes a problem. Here's an intial
attempt to use atatic polymorphism and multiple levels of inheritance:
        verb(
    template <class Derived>
    class Vehicle
    {
        public:
            void mass() 
            {
                static_cast<Derived *>(this)->vmass();
            }
    };
    
    class Car: public Vehicle<Car>
    {
        friend void Vehicle<Car>::mass();
        void vmass();
    };

    class Truck: public Car
    {
        void vmass();
    };
        )
        itemization(
        it() If tt(Truck) inherits from tt(Car), then tt(Truck) implicitly
derives from tt(Vehicle<Car>), as tt(Car) derives from
tt(Vehicle<Car>). Consequently, when tt(Truck{}.mass()) is called it is not
tt(Truck::vmass) that's activated, but em(Car's) tt(vmass) function. But
tt(Truck) em(must) derive from tt(Car) in order to use tt(Car's) protected
features and to add tt(Car's) public features to its own public
interface. COMMENT(see examples/staticpolymorphism/double.cc)
        it() Multiple inheritance also doesn't solve the issue: when
inheriting tt(Truck) from tt(Vehicle<Truck>) em(and) from tt(Car) 
results in a class tt(Truck) that em(also) inherits from
tt(Vehicle<Car>) (through tt(Truck's Car) base class), and compilation fails
as the compiler encounters an ambiguity when instantiating tt(Vehicle::mass):
should it call tt(Class::vmass) or should it call tt(Truck::vmass)?
    COMMENT(see examples/staticpolymorphism/multiple.cc)
    )
    To solve this problem (i.e., to ensure that tt(Truck{}.mass()) calls
tt(Truck::vmass) the redefinable interface must be separated 
from the inheritable interface.

In derived classes the protected and public interfaces of (direct or indirect)
base classes are made available using standard inheritance. This is shown in
the left-hand side of figure ref(STATPOLY).  

    figure(classtemplates/converting)
        (Vehicle Static Polymorphic Class Design)(STATPOLY)

Each of the left-hand side classes is used as a base class, together with the
static polymorhic base class, to create a statically polymorphic derived class
defining its own implementation of the static base class's redefinable
interface.

FBB: SO FAR

The
right-hand side of of figure ref(STATPOLY) shows this part of the design. The
tt(XBase) classes in the left-hand side of figure ref(STATPOLY) contain the
non-redefinable elements of the original dynamically polymorphic classes. They
should of course still be available to the statically polymorphic classes
(shown in the right-hand side of figure ref(STATPOLY)). This is realized using
tt(friend) declarations: the tt(XBase) classes declare `tt(friend class X)',
after which tt(XBase) essentially has become part of the class tt(X).

Now that we've analyzed the design of statically polymorphic classes using
multiple levels of inheritance we're ready for the conversion of the
tt(Vehicle, Car), and tt(Truck) dynamically polymorphic classes to statically
polymorphic classes. To concentrate on the actual conversion process the
design of the classes is kept simple. E.g., usually appearing elements like
constructors were not included in the examples. Furthermore, to save some
space all implementations of member functions are provided in-class.

First the class tt(Vehicle). tt(Vehicle's) non-redifinable interface is moved
to a class tt(VehicleBase), and tt(Vehicle) itself is turned into a statically
polymorphic base class. Here only tt(Vehicle::d_massFactor) needs to be moved
to tt(VehicleBase). But in general all members of the original dynamically
polymorphic base class that do not use or implement virtual members should be
moved to the tt(XBase) class. tt(VehicleBase) also declares tt(Vehicle) to be
its friend, so tt(Vehicle) is not denied access to its members, now living in
tt(VehicleBase). Here is tt(VehicleBase):
        verb(
    class VehicleBase
    {
        // original Vehicle members, not implementing the
        // redefinable interface 

        template <class Derived>
        friend class Vehicle;

        size_t d_massFactor = 1;
    };
        )
    
The statically polymorphic tt(Vehicle) base class implements the redefinable
interface. All other facilities are in tt(VehicleBase), from which it is
derived. Here is tt(VehicleBase):
        verb(
    template <class Derived>
    class Vehicle: public VehicleBase
    {
        public:
            int mass() const
            {
                return d_massFactor *
                        static_cast<Derived const *>(this)->vmass();
            }
    };
        )
    In this implementation tt(Vehicle) does not implement its own tt(vmass)
member. We cannot define tt(Vehicle<Vehicle>), and with static polymorphism
the base class is essentially comparable to an abstract base class. If this is
not required, then a default class can be specified for tt(Vehicle's Derived)
class, implementing the redefinable interface of the original dynamically
polymorphic base class (allowing definitions like tt(Vehicle<> vehicle)).

Likewise the class tt(Car) is split into tt(CarBase) and
tt(Car). tt(CarBase) uses standard inheritance to inherit tt(VehicleBase's)
protected and public interface. Here is its implementation, adding a private
data member for illustration purposes:
        verb(
    class CarBase: public VehicleBase
    {
        // original Car members, not implementing the
        // redefinable interface 

        int x = 1000;
        friend class Car;
    };
        )       
 
The class tt(Car) receives tt(CarBase)'s members through
inheritance. Furthermore, it inherits from tt(Vehicle<Car>), implementing its
own version of tt(Vehicle's) redefinable interface. Note the specific
tt(friend) declaration, allowing tt(Vehicle<Car>) to access tt(Car)'s private
tt(vmass) member:
        verb(
    class Car: public CarBase, public Vehicle<Car>
    {
        friend class Vehicle<Car>;

        int vmass() const
        {
           return x;
        }
    };
        )

    This design pattern can be used for deeper levels of inheritance as
well. Once more we need to split a polymorphic class into two separate
classes: the polymorphic class tt(Truck) is split into tt(TruckBase) and a
statically polymorphic class tt(Truck), implementing tt(Vehicle's) redefinable
interface. Here is tt(TruckBase), inheriting from tt(CarBase), and thus also
from tt(VehicleBase):
        verb(
    class TruckBase: public CarBase
    {
        // original Truck members, not implementing the
        // redefinable interface 

        friend class Truck;
    };
        )
    
Finally, we finish our class conversion for the class tt(Truck), now
implementing its own version of the statically polymorphic class tt(Vehicle):
        verb(
    class Truck: public TruckBase, public Vehicle<Truck>
    {
        friend class Vehicle<Truck>;

        private:
            int vmass() const
            {
                return 15000;
            }
    };
        )

The original function tt(void fun(Vehicle &vehicle)) still needs to be
converted to a function template. Here is its definition:
        verb(
    template <class Vehicle>
    void fun(Vehicle &vehicle)
    {
        cout << vehicle.mass() << '\n';
    }
        )
    Note that tt(Vehicle) is just a formal name. When an object is passed to
tt(fun) it must offer a member tt(mass), or compilation will fail. If the
object is in fact a tt(Car) or tt(Truck), then their tt(Vehicle<Type>) static
base class member tt(mass) is called, which in turn uses static polymorphism
to call the member tt(vmass) as implemented by the actually passed class
type. The following tt(main) function displays, respectively, 1000 and 15000:
        verb(
    int main()
    {
        Car car;
        fun(car);
    
        Truck truck;
        fun(truck);
    }
        )
    Realize that this program implements tt(fun) twice, rather than once in
the case of dynamic polymorphism. The same holds true for the tt(Vehicle)
class template: two implementations, one for the tt(Car) type, and one for the
tt(Truck) type. The statically polumorphic program will be slightly faster,
though. 



