So you've decided to convert some of your dynamically polymorphic classes into
statically polymorphic classes. How to realize the conversion?

In chapter ref(POLYMORPHISM) the base class tt(Vehicle) and some derived
classes were introduced. tt(Vehicle, Auto) and tt(Truck)'s interfaces
look like this (concentrating on the members that are involved in their
polymorphic behavior):
        verb(
    class Vehicle
    {
        public:
            int mass() const;
            int si_mass() const;

        private:
            virtual int vmass() const;
    };

    class Auto: public Vehicle
    {
        size_t d_mass;
        private:
            int vmass() const override;
    }
        
    class Truck: public Auto
    {
        size_t d_mass;
        private:
            int vmass() const override;
    }
        )        
    Thee members of the user-interface were implemented like this:
        verb(
    int Vehicle::mass() const
    {
        return d_massFactor * si_mass();
    }
    int Vehicle::si_mass() const
    {
        return vmass();
    }
        )

    We start by converting the base class to a static polymorphic class. This
is accomplished in three steps:
    itemization(
    it() Conversion of the base class to a class template declaring a template
        type parameter tt(Derived);
    it() Removal of all virtual members from the interface;
    it() Replacing calls of the virtual members calling these members as
        members of the tt(Derived) template type.
    )

    Thus, the class tt(Vehicle) becomes:
        verb(
    template <type Derived>
    class Vehicle
    {
        public:
            int mass() const;
            int si_mass() const;
    };
        )
    Its member tt(si_mass) now calls the derived class member using a
tt(static_cast):
        verb(
    template <class Derived>
    int Vehicle<Derived>::si_mass() const
    {
        return static_cast<Derived *>(this)->vmass();
    }
        )
    Its member tt(mass) doesn't depend on (previously) virtual members, so its
implementation remains as-is, but the member is converted to a function
template: 
        verb(
    template <class Derived>
    int Vehicle<Derived>::mass() const
    {
        return d_massFactor * si_mass();
    }
        )

    Next, derived classes must be converted to static polymorphic
classes. Here we must realize that derived classes serve two functions: first,
they define facilities (data members, member functions) that exceed those of
the static polymorphic base class. E.g., essentially the class tt(Vehicle)
merely defines the polymorphic user interface, but tt(Auto) and tt(Vehicle)
offer data members and possibly additional members as well. Second, derived
classes implement the redefinable interface in a way that fits their
purpose. E.g., tt(Auto's vmass) returns a car's mass in kg., tt(Truck's vmass)
returns a truck's mass as the sum of the tractor and trailer masses. 

As we've seen in the previous section, a statically polymorphic derived class
derives from the base class by using its own class type as argument to the
base class's type parameter. This works fine if there's only one level of
inheritance, but with multiple levels of inheritance (e.g., tt(Truck -> Auto
-> Vehicle)) tt(Truck)'s inheritance specification becomes a problem: if it is
inheriting from tt(Auto), then it implicitly derives from tt(Vehicle<Auto>),
and tt(Auto's vmass) is called by tt(Vehicle::interface). But tt(Truck) must
inherit from tt(Auto) to be able to use tt(Auto's) features. On the other
hand, we cannot also inherit tt(Truck) from tt(Vehicle<Truck>) as this results
in a class tt(Truck) also inheriting from tt(Vehicle<Auto>) (through
tt(Truck's Auto) base class.

In the context of polymorphism it cannot be ruled out that classes use
multiple levels of inheritance. When static polymorphism is used classes must
carefully be designed: only the part implementing their redefinable interfaces
must inherit from the base class. This design is accomplished as follows
(using the classes tt(Auto) and tt(Truck) to illustrate the approach, but the
design should be applied to all classes (indirectly) inheriting from the
static polymorphic base class):
    itemization(
    it() tt(Auto)'s non-virtual members are collected in a separate class
        (e.g., tt(AutoBase));
    it() tt(Auto) publicly derives from tt(AutoBase) and from
        tt(Vehicle<Auto>), declaring the members of tt(Vehicle)'s user
        interface calling members from tt(Vehicle)'s user interface calling 
        members from its template class type its friend;
    it() tt(AutoBase) declares tt(friend class Auto), which essentially turns
        tt(AutoBase) into a constituent part of tt(Auto);
    it() Classes originally derived from tt(Auto) (e.g., tt(Truck) should
        implement the same separation: tt(TruckBase) collects tt(Truck)'s
        non-virtual members, tt(Truck) should merely contain the redefinable
        interface);
    it() tt(Truck) originally derived from tt(Auto). Under the new design
        tt(TruckBase) should derive from tt(AutoBase), and tt(Truck) itself
        should inherit from tt(TruckBase) and from tt(Vehicle<Truck>).
    )
   
     
steps are taken:


    The class tt(Auto) is derived from tt(Auto), receiving tt(Auto) as its
template class type:
        verb(
    class Auto: public Vehicle<Auto>
    {
        private:
            int vmass() const override;
    }
    









