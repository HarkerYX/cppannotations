Section ref(NEGATORS) covered the tt(not1) and tt(not2) negators. These
negators have limited use as they cannot always be used in combination with
the tt(bind) function template (cf. section ref(BIND)), and they are limited
to situations where one or two arguments are used. It is likely that in the
upcoming i(C++17) standard they are either deprecated or augmented with a more
generic negator, for which the name ti(not_fn) has been coined.

In this section we'll have a look at a possible bare bones 
implementation of such a tt(not_fn) negator.

First we look at how tt(not_fn) can be used. In section ref(NEGATORS) it was
noted that of the following two statements the second one won't compile:
        verb(
    count_if(vs.begin(), vs.end(), 
        bind(not2(greater_equal<string>()), _1, reftext));

    count_if(vs.begin(), vs.end(),
        not1(bind(greater_equal<string>()), _1, reftext));
        )

The alternative, tt(not_fn), should be usable in both situations, resulting in
the following statements:
        verb(
    count_if(vs.begin(), vs.end(),                          // 1
        bind(not_fn(greater_equal<string>()), _1, reftext));

    count_if(vs.begin(), vs.end(),                          // 2
        not_fn(bind(greater_equal<string>()), _1, reftext));
        )

Here, tt(not_fn) is called with an argument which happens to be tt(bind's)
return value. tt(Bind) returns a functor, and its actual type is simply
determined by the compiler. Hence tt(not_fn) merely needs a tt(typename Fun)
template type parameter. Depending on the situation, the functor's function
call operators may receive different types and numbers of arguments (in the
example, where tt(count_if) is used it receives one argument), and those
arguments must be forwarded to the function object which is returned by
tt(bind). Summarizing we have this situation:
        itemization(
        it() tt(bind) returns a functor, whose function call operator may 
            expect arguments. A functor may also directly be defined, as with,
            e.g., tt(greater_equal<string>()) in statement 1;
        it() tt(not_fn) receives the functor, and passes it on to an object of
            some class (e.g., tt(struct not_fn_)), which is also a functor;
        it() this tt(not_fn_) object is returned by tt(not_fn), becoming the
            functor which is called by, e.g., a generic algorithm like
            tt(count_if);
        it() the generic algorithm calls the functor's function call operator,
            passing it a certain number of arguments of certain types.
        it() tt(not_fn_'s) function call operator receives the arguments, and
            perfectly forwards them to the functor, originally specified when
            tt(not_fn) was called;
        )
    The first of these steps simply produces a functor which is passed to
tt(not_fn), defined like this:
        verb(
    template <typename Fun>
    not_fn_<Fun> not_fn(Fun const &fun)
    {
        return not_fn_<Fun>(fun);
    }
        )
    This function returns a tt(not_fn_) function object, initialized with the
functor to call (e.g., tt(greater_equal<string>()) or the functor returned by
tt(bind)).

    tt(Not_fn_) object's constructor saves a reference to the received
functor, to be called later by its function call operator:
        verb(
    template <typename Fun>
    struct not_fn_
    {
        Fun const &d_fun;
    
        not_fn_(Fun const &fun)
        :
            d_fun(fun)
        {}
        ...
    };
        )
    
    Then, the tt(not_fn_)'s function call operator (receiving its arguments
from, e.g., a generic algorithm), perfectly forwards its arguments to the
stored function object, returning its negated return value:
        verb(
    template <typename ... ParTypes>
    bool operator()(ParTypes && ...types)
    {
        return not d_fun(std::forward<ParTypes>(types)...);
    }
        )

    The example below shows how tt(not_fn) can be used: using
tt(equal_to<string>()) two ways to count the number of elements in a string
vector that are not equal to tt("b") are shown. The program's output displays
two twos:
        verb(
    int main()
    {
        vector<string> vs {"a", "a", "b"};
        string reftext {"b"};
    
        cout << 
            count_if(vs.begin(), vs.end(),
                bind(not_fn(equal_to<string>()), _1, reftext)) << '\n' <<
            count_if(vs.begin(), vs.end(), 
                not_fn(bind(equal_to<string>(), _1, reftext))) << '\n';
    }
        )
COMMENT(see also examples/notfn.cc)
