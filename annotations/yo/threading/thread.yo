Multi threading in bf(C++) starts off with objects of the 
class hi(thread)tt(std::thread). Each object of this class can 
handles a separate thread.

Before using tt(Thread) objects the tthi(thread) header file must be included.

Thread objects can be constructed in various ways:
    itemization(
    ittq(thread() noexcept)
       (The default constructor creates a tt(thread) object. As it receives no
function to execute, it does not start a separate thread of execution. It is
used, e.g., as a data member of a class, allowing class objects to start a
separate thread at some later point in time;)

    ittq(thread(thread &&tmp) noexcept)
       (The move constructor takes ownership of the thread controlled by
tt(tmp), while tt(tmp), if it runs a thread, loses control over its
thread. Following this, tt(tmp) is in its default state, and the newly created
thread is responsible for calling, e.g., tt(join).)

    ittq(explicit thread(Fun &&fun, Args &&...args))
       (This em(member template) (cf. section ref(MEMTEMP)) expects a function
(or functor) as its first argument. The function is immediately started as a
separate thread. If the function (or functor) expects arguments, then these
arguments can be passed to the tt(thread's) constructor immediately following
its first (function) argument. Additional arguments are passed with their
proper types and values to tt(fun). Following the tt(thread) object's
construction, a separately running thread of execution is started.

The notation tt(Arg &&...args) indicates that any additional arguments are
passed as is to the function. The types of the arguments that are passed to
the tt(thread) constructor and that are expected by the called function must
match: values must be values, references must be reference, r-value references
must be r-value references (or move construction must be supported). The
following example illustrates this requirement:
    verbnrs(examples/threadargs.cc)
    itemization(
    it() At lines 43 through 45 we see a value, reference, and and r-value
reference being passed to a tt(std::thread): with 
the functions running the threads expecting matching argument types.
    
    it() Line 47 fails to compile, as a value argument doesn't match the
reference expected by tt(refArg). Note that this problem was solved in line 43
by using the tt(std::ref) function.

    it() On the other hand lines 49 and 58 compile OK, as tt(int) values and
class-types supporting move operations can be passed as values to functions
expecting r-value references. In this case notice that the functions expecting
the r-value references do not access the provided arguments (except for the
actions performed by their move constructors), but use move construction to
create temporary values or objects on which the functions operate.

    it() Lines 52 and 55 won't compile as the tt(NoMove) struct doesn't offer
a move constructor.
    )

    Be careful when passing local variables as arguments to thread objects: if
the thread continues when the function whose local variable is used
terminates, then the thread uses a wild pointer or wild reference, as the
local variable no longer exists. To prevent this from happening (illustrated
by the next example):
        itemization(
        it() pass an anonymous copy of the local variable as argument to the
tt(thread) constructor, or
        it() call tt(join) on the thread object to make sure the thread has
finished within the local variable's lifetime.
        )
    verbnrs(examples/locals.cc)
    In line 18 be sure not to call tt(std::ref(text)) instead of
tt(std::string(text)).

    If the thread cannot be created a tt(std::system_error) exception is
thrown.
        )
    )
    The class tt(std::thread) does not provide a copy constructor.

    A thread ends when the function executing a thread finishes. When a
tt(thread) object is destroyed while its thread function is still running,
tt(terminate) is called, aborting the program's end. Bad news: the destructors
of existing objects aren't called and exceptions that are thrown are left
uncaught. This happens in the following program as the thread is still active
when tt(main) ends:
        verbinclude(examples/terminate.cc)
        
    
The members of the class tt(thread) are:
    itemization(
    ithtq(detach)(void detach())
       (Requires tt(joinable) (see below) to return tt(true).  The thread for
which tt(detach) is called continues its execution. The (e.g., parent) thread
calling tt(detach) continues its execution immediately beyond the
tt(detach)-call.  After calling tt(object.detach()), `tt(object)' no longer
represents the, possibly still continuing but now detached, thread of
execution. It is the detached thread's implementation's responsibility to
release its resources when its execution ends.

Since tt(detach) disconnects a thread from the running program, e.g.,
tt(main) no longer can wait for the thread's completion.  As a program
ends when tt(main) ends, its still running detached threads also stop, and
program may not properly complete all its threads, as demonstrated by
the following example: 
            verbinclude(examples/threads2.cc)
        )

    ithtq(get_id)(id get_id() const noexcept)
       (If the current object does not represent a running thread
hi(id)tt(thread::id) is returned. Otherwise, tt(this_thread::get_id()) is
returned for the running thread that is associated with the object for which
tt(get_id) is called is returned.)

    ithtq(join)(void join())
       (Requires tt(joinable) to return tt(true).  Blocks the thread calling
tt(join) until the thread for which tt(join) is called has
completed. Following its completion the object whose tt(join) member was
called no longer represents a running thread, and its tt(get_id) member will
return tt(std::thread::id).

        This member was used in several examples shown so far. As noted: when
tt(main) ends while a joinable thread is still running, tt(terminate) is
called, aborting the program.)

    ithtq(joinable)(bool joinable() const noexcept)
       (returns tt(object.get_id() != id()), where tt(object) is the
        tt(thread) object for which tt(joinable) was called.)

    ithtq(swap)(void swap(thread &other) noexcept)
       (The states of the tt(thread) object for which tt(swap) was called and
        tt(other) are swapped. Note that threads may always be swapped, even
        when their thread functions are currently being executed.)
    )





The class tt(thread) supports the move assignment operator:
    itemization(
    itt(thread &operator=(thread &&tmp) noexcept):
        If the operator's left-hand side operand (lhs) is a joinable thread,
then tt(terminate) is called. Otherwise, tt(other)'s state is assigned to the
operator's lhs and sets tt(other) to the thread's default constructed state.
    )

Since the tt(tread(Fun &&fun, Args &&...args)) constructor not only accepts
functions but also function objects as its argument, a emi(local context) may
be passed to the function object's constructor. Here is an example of a thread
to which a function object is passed which is provided with a local context:
        verbinclude(examples/functorthread.cc)
    Note the argument tt(&cout) that is passed to tt(funThread) and the
definition tt(ostream *out) parameter of the tt(funThread)'s function call
operator. Here tt(cout) cannot be used (in combination with an tt(ostream &out)
parameter), since the latter parameter is not move-constructible, whereas a
pointer em(is).




| Each tt(thread) object represents one unique thread of execution, but its
| unique thread may be transferred to another tt(thread) object. In this
| situation there remains but a single tt(thread) object that represents the
| running thread.
| 
| If a threads of execution loses its association with a tt(thread) object that
| thread is said to be hi(thread: detached) em(detached). Conversely, tt(thread)
| objects by themselves are not necessarily associated with a running thread of
| execution: following the default construction, a move operation in which a
| tt(thread) object acts as  the source tt(thread) or after detaching or joining
| threads the tt(thread) object may still exist, albeit in a state where it is
| not or no longer associated with a running thread.

