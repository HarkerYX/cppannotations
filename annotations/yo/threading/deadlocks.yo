A deadlock occurs when two locks are required to process data, but one thread
obtains the first lock and another thread obtains the second lock. The C++11
standard defines the generic
    hi(lock)tt(std::lock) and hi(try_lock)std::try_lock) functions that can be
used to help preventing such situations. 

Before these functions  can be used the tthi(mutex) header file must be
included

    In the following overview tt(L1 &l1, ...) represents one or more
references to objects of lockable types:
    ittq(void std::lock(L1 &l1, ...))
        quote(
            When the function returns locks were obtained on all tt(li)
objects. If a lock could not be obtained for at least one of the objects, then
all locks obtained so far are relased, even if the object for which no lock
could be obtained threw an exception.)
    ittq(int std::try_lock(L1 &l1, ...))
        quote(
    This function calls the lockable objects' tt(try_lock) members. If all
locks could be obtained, then -1 is returned. Otherwise the (0-based) index of
the first argument which could not be locked is returned, releasing all
previously obtained locks)
    )
    
As an example consider the following small multi-threaded program: The threads
use mutexes to obtain unique access to tt(cout) and an tt(int value). However,
tt(fun1) first locks tt(cout) (line 7), and then tt(value) (line 10); tt(fun2)
first locks tt(value) (line 16) and then tt(cout) (line 19). Clearly, if
tt(fun1) has locked tt(cout) tt(fun2) can't obtain the lock until tt(fun1) has
released it. Unfortunately, tt(fun2) has locked tt(value), and the functions
only release their locks when returning. But in order to access the
information in tt(value) tt(fun1) it must have obtained a lock on tt(value),
which it can't, as tt(fun2) has already locked tt(value): the threads are
waiting for each other, and neither thread gives in.
        verbinclude(-ns4 //code examples/deadlock.cc)

A good recipe for avoiding deadlocks is to prevent nested (or multiple
mutex lock calls. But if multiple mutexes must be used, always obtain the
locks in the same order. Rather than doing this yourself, tt(std::lock) and
tt(std::try_lock) should be used whenever possible to obtain multiple mutex
locks. These functions accept multiple arguments, which must be lockable types
like tt(lock_guard, unique_lock,) or even a plain tt(mutex). 

The recipe to aWhen using multiple locks
These functions can be
used to lock multiple mutexes in one atomic action. Here is an example:
        verb(
    struct SafeString
    {
        std::mutex  d_mutex;
        std::string d_text;
    };

    void calledByThread(SafeString &first, SafeString &second)
    {
        std::unique_lock<std::mutex>                        // 1
                lock_first(first.d_mutex, std::defer_lock);

        std::unique_lock<std::mutex>                        // 2
                lock_second(second.d_mutex, std::defer_lock);

        std::lock(lock_first, lock_second);                 // 3

        safeProcess(first.d_text, second.d_text);
    }
        )
    At 1 and 2 tt(unique_locks) are created. Locking is deferred until calling
tt(std::lock) at 3. Having obtained the lock, the two tt(SafeString) text
members can both be safely processed by tt(calledByThread).

Another problematic issue with threads involves initialization. If multiple
threads are running and only the first thread calling the initialization code
should actually perform the initialization then this problem should not be
solved using mutexes. 

Although proper synchronization is realized, the synchronization is performed
time and again for every thread. The C++11 standard offers several ways to
perform a proper initialization:
    itemization(
    it() First, suppose your constructor is declared with the ti(constexpr)
keyword (cf. section ref(CONSTEXPR)), satisfying the requirements for constant
initialization. In this case, an object of static storage lifetime,
initialized using that constructor, is guaranteed to be initialized before any
code is run as part of the static initialization phase. This is the option
chosen for tt(std::mutex), because it eliminates the possibility of race
conditions with initialization of mutexes at a global scope. Here is an
example, using in-class implementations for brevity:
        verb(
class MyClass
{
    int d_i;

    public:
        constexpr MyClass(int i = 0)
        :
            d_i(0)
        {}

    void action();
};

MyClass myObject;   // static initialization with constexpr constructor

int foo();
myClass other(42 + foo());  // dynamic initialization

void f()
{
    other.action();         // is other initialized in some thread?
}
    )
    it() Second, a static variable defined within a compound statement may be
used (e.g., a static local variable within a function body).  In C++ static
variables hi(static variable: initialization) defined within a compound
statement are initialized the first time the function is called at the point
in the code where the static variable is defined as illustrated by the
following example:
        verbinclude(-a examples/staticlocal.cc)
    This feature causes a thread to wait automatically if another thread is
still initializing the static data (note that em(non-static) data never cause
problems, as each non-static local variables have lifes that are completely
restricted to their own threads).
    it() If the above two approaches can't be used. The combined use of
 hi(call_once)tt(std::call_once) and hi(once_flag) tt(std::once_flag) result
in one-time execution of a specified function as illustrated by the next
example:
        verb(
std::string *global;
std::once_flag globalFlag;

void initializeGlobal()
{
    global = new std::string("Hello world (why not?)");
}
void safeUse()
{
    std::call_once(globalFlag, initializeGlobal);
    process(*global);
}
        )
    )
