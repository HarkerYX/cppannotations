#include <iostream>
#include <string>
#include <thread>
#include <queue>
#include <future>
#include <mutex>

#include "semaphore/semaphore.h"
#include "cmdfork/cmdfork.h"

using namespace std;

typedef packaged_task<string (string const &fname)> PackagedTask;

class Task
{
    string filename;
    PackagedTask task;

    public:
        Task()  = default;
    
        Task(string const &file, PackagedTask &&tmp)
        :
            filename(file),
            task(move(tmp))
        {}
    
        void operator()()
        {
            task(filename);
        }
    
        shared_future<string> result()
        {
            return task.get_future().share();
        }
};

class TaskQueue
{
    mutex d_mutex;
    queue<Task> d_queue;

    public:
        void push(Task &&tmp)
        {
            lock_guard<mutex> lk(d_mutex);
            d_queue.push(move(tmp));
        }    

        void popFront(Task &dest)
        {
            lock_guard<mutex> lk(d_mutex);
            dest = move(d_queue.front());
            d_queue.pop();
        }

        bool empty() const
        {
            return d_queue.empty();
        }
};

class GuardBool
{
    mutable mutex d_mutex;
    bool d_value = false;

    public:
        operator bool() const
        {
            lock_guard<mutex> lk(d_mutex);
            return d_value;
        }
        GuardBool &operator=(bool value)
        {
            lock_guard<mutex> lk(d_mutex);
            d_value = value;
            return *this;
        }
};

    
extern TaskQueue g_taskQ;

extern mutex g_resultQMutex;
extern queue<shared_future<string>> g_resultQ;
extern condition_variable g_resultCond;

extern GuardBool g_done;

extern Semaphore g_workforce;
extern Semaphore g_worker;

void workForce();                // start all worker threads

void jobs();
bool dispatch(string const &line);
void worker(int nr);
string compile(string const &line);
void results();
