#include <iostream>
#include <string>
#include <thread>
#include <queue>
#include <future>
#include <mutex>

#include "semaphore/semaphore.h"
#include "cmdfork/cmdfork.h"

using namespace std;

typedef packaged_task<string (string const &fname)> PackagedTask;

class Task
{
    string filename;
    PackagedTask task;

    public:
        Task()  = default;
    
        Task(string const &file, PackagedTask &&tmp)
        :
            filename(file),
            task(move(tmp))
        {}
    
        void operator()()
        {
            task(filename);
        }
    
        shared_future<string> result()
        {
            return task.get_future().share();
        }
};

//template <typename Type>
//class GuardQueue
//{
//    mutex d_mutex;
//  queue<Type> d_queue;
//
//    public:
//      void push(Type &&tmp)
//      {
//
//      void popFront(Type &dest)
//      {
//          lock_guard<mutex> lk(d_mutex);
//          dest = dest.front();
//      
//};

extern Guard g_taskGuard;
extern mutex g_taskQMutex;
extern queue<Task> g_taskQ;

extern mutex g_resultQMutex;
extern queue<shared_future<string>> g_resultQ;
extern condition_variable g_resultCond;

extern mutex g_doneMutex;
extern bool g_done;

extern mutex g_qpMutex;
extern queue<PackagedTask> g_qp;

extern Semaphore g_workforce;
extern Semaphore g_worker;

void workForce();                // start all worker threads

void dispatch();
void worker(int nr);
string compile(string const &line);
void results();
