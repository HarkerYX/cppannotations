In this section the function template hi(async)tt(std::async) is
covered. tt(Async) is used to start asynchronous tasks, providing facilities
not offered by the basic tt(std::thread) class.

Before using the function tt(async) the tthi(future) header file must be
included. 

When starting a thread using the facilities of the class tt(std::thread) the
initiating thread at some point commonly calls the thread's tt(join)
method. In the meantime the sub-thread must have finished or the thread has to
wait for tt(join) to complete. While this often is a sensible course of
action, it may not always be. E.g., the function implementing the sub-thread's
actions may have a non-void return value, or it may throw an exception. In
those cases tt(join) won't help: if an exception leaves a sub-thread your
program ends. Here is an example:
    verbinclude(-s4 //code examples/throwing.cc)
    In line 3 tt(thrower) throws an exception, leaving the sub-thread. This
exception is not caught by tt(main)'s try-block (as it is defined in
another thread) and so the program terminates.

This scenario doesn't occur when the function template tt(async) is
used. tt(Async) may start a new asynchronous task, and the activating thread
may retrieve the return value of the function implementing the asynchronous
task or any exception leaving that function from a tt(std::future) object
returned by the tt(async) function. Basically, tt(async) is called similarly
to the way a thread is started using tt(std::thread): it is passed a function
and optionally arguments which are passed to the function.

Although the function implementing the asynchronous task may be passed as
first argument, tt(async) first argument may also be a value of the strongly
typed enumeration hi(deferred)hi(async)hi(launch)tt(std::launch):
        verb(
    enum class launch
    {
        async,
        deferred
    };
        )
    When passing tt(launch::async) the asynchronous task immediately starts;
when passing tt(launch::deferred) the asynchronous task is deferred. When 
tt(std::launch) is not specified the default value tt(launch::async |
launch::deferred) is used, giving the implementation freedom of choice, 
usually resulting in deferring execution of the asynchronous task.

So, here is the first example again, this time using tt(async) to start the
sub-thread:
    verbinclude(-sn4 //code examples/async1.cc)
    Now the threads immediately start, but although the results are
available around line 13, the thrown exception isn't terminating the
program. The first thread's return value is made available in line 16, the
exception thrown by the second thread is simply caught by main's try-block
(line 19).

The function template tt(async) has several overloaded versions:
    itemization(
    it() The basic form expects a function or functor as its first argument,
returning a tt(std::future) holding the function's return value or  exception
thrown by the function:
        verb(
    template <typename Function, class ...Args>
    std::future<
        typename std::result_of<
                            Function(Args ...)
                 >::type
    > std::async(Function &&fun, Args &&...args);
        )

    it() Alternatively, the first argument may be the address of a member
function, in which case the second argument is (a pointer to) an object of the
member function's class for which the member function is called. Any
remaining arguments are passed to the member function (see also the remarks
below).

    it() The first argument may also be a combination (using the tt(bit_or)
operator) of the enumeration values of the tt(std::launch) enumeration:
        verb(
    template <class Function, class ...Args>
    std::future<typename std::result_of<Function(Args ...)>::type> 
        std::async(std::launch policy, Function &&fun, Args &&...args);
        )

    it() Alternatively, the second argument may be the address of a member
function, in which case the third argument is (a pointer to) an object of the
member function's class for which the member function is called. Any remaining
arguments are passed to the member function (see also the remarks below).
    )
    When calling tt(async) all arguments except for the tt(std::launch)
argument must be references, pointers or move-constructible. When a member
function is specified, then the object for which the member function is called
must be a named object, an anonymous object, or a pointer to a named
object. When passing a named object to the tt(async) function template then
copy construction is used to create an object which is passed to the
thread-launcher. When an anonymous object is passed to the tt(async) function
template then move construction is used to pass the anonymous object to the
thread launcher. When the thread itself starts another move construction is
used to create an object for the duration of the sub-thread. When a pointer to
an object is passed, the sub-thread uses the object referred to by the
pointer, and neither copy- nor move-construction is required. However, when
using a pointer to an object the programmer should make sure that the
object's lifetime exceeds the duration of the thread (note that this is not
automatically guaranteed, as the asynchronous task may not start before the
future's tt(get) member is called).
    
Because of the default tt(std::launch::deferred | std::launch::async) argument
used by the basic tt(async) call it is likely that the function that is
specified when calling tt(async) won't be called. The tt(launch::deferred)
policy allows tt(async) to defer evaluation until the implementation is ready
for it, or the program explicitly asks for it. Consider the following program:
        verbinclude(-ans4 examples/async1.cc)
    Although tt(async) is called in line 9, when the program is run its output
may not show tt(fun's) output line.  This happens because of
tt(lauch::deferred): the system simply defers tt(fun's) execution until
requested, which never occurs. But the tt(future) object that's returned by
tt(async) has a member tt(wait). Once tt(wait) returns the shred state must be
available. In other words: tt(fun) must have finished. Here is what happens
when line 14 is changed into tt(async(fun).wait()):
        verb(
    First async call starts
        hello from fun
    First async call ends
    Second async call starts
        hello from fun
    Second async call ends
        )
    Evaluation of tt(fun) can thus be controlled to the point where we want
it, maybe even after calling tt(asyncCall), as shown in the next
example. 

The tt(std::async) function template is used to start a thread, making its
results available in the calling thread. On the other hand, a thread may
be able to em(prepare) (package) a thread (a task) 
for execution but leave the task's execution to another thread. Scenarios like
this are implemented using objects of the class tt(std::package_task), which
is the topic of the next section.
