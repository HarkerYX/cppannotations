In this section the function template hi(async)tt(std::async) is
covered. tt(Async) is used to start asynchronous tasks, providing facilities
not offered by the basic tt(std::thread) class.

Before using the function tt(async) the tthi(future) header file must be
included. 

When starting a thread using the facilities of the class tt(std::thread) the
initiating thread at some point commonly calls the thread's tt(join)
method. In the meantime the sub-thread must have finished or the thread has to
wait for tt(join) to complete. While this often is a sensible course of
action, it may not always be. E.g., the function implementing the sub-thread's
actions may have a non-void return value, or it may throw an exception. In
those cases tt(join) won't help: if an exception leaves a sub-thread your
program ends. Here is an example:
    verbinclude(-s4 //code examples/throwing.cc)
    In line 3 tt(thrower) throws an exception, leaving the sub-thread. This
exception is not caught by tt(main)'s try-block (as it is defined in
another thread) and so the program terminates.

This scenario doesn't happen when the function template tt(async) is
used. tt(Async) may start a new asynchronous task, and the activating thread
may retrieve the return value of the function implementing the asynchronous
task or any exception leaving that function from a tt(std::future) object
returned by the tt(async) function. Basically, tt(async) is called similarly
to the way a thread is started using tt(std::thread): it is passed a function
and optionally arguments which are passed to the function. 

Although the function implementing the asynchronous task may be passed as
first argument, tt(async) first argument may also be a value of the strongly
typed enumeration hi(deferred)hi(async)hi(launch)tt(std::launch):
        verb(
    enum class launch
    {
        async,
        deferred
    };
        )
    When passing tt(launch::async) the asynchronous task immediately starts;
when passing tt(launch::deferred) the asynchronous task is deferred. When 
tt(std::launch) is not specified the default value tt(launch::async |
launch::deferred) is used, giving the implementation freedom of choice, 
usually resulting in deferring execution of the asynchronous task.

So, here is the first example again, this time using tt(async) to start the
sub-thread:
    verbinclude(-sn4 //code examples/async1.cc)
    Now the threads are started immediately, but although the results are
available around line 13, the thrown exception isn't terminating the
program. The first thread's return value is made available in line 16, the
exception thrown by the second thread is simply caught by main's try-block
(line 19).

The function template tt(async) has several overloaded versions:
    itemization(
    it() The basic form expects a function or functor as its first argument,
returning a tt(std::future) holding the function's return value or  exception
thrown by the function:
        verb(
    template <typename Function, class ...Args>
    std::future<
        typename std::result_of<
                            Function(Args ...)
                 >::type
    > std::async(Function &&fun, Args &&...args);
        )

    it() Alternatively, the first argument may be the address of a member
function, in which case the second argument is (a pointer to) an object of the
member function's class for which the member function is called. Any
remaining arguments are passed to the member function (see also the remarks
below).

    it() The first argument may also be a combination (using the tt(bit_or)
operator) of the enumeration values of the tt(std::launch) enumeration:
        verb(
    template <class Function, class ...Args>
    std::future<typename std::result_of<Function(Args ...)>::type> 
        std::async(std::launch policy, Function &&fun, Args &&...args);
        )

    it() Alternatively, the second argument may be the address of a member
function, in which case the third argument is (a pointer to) an object of the
member function's class for which the member function is called. Any remaining
arguments are passed to the member function (see also the remarks below).
    )
    When calling tt(async) all arguments except for the tt(std::launch)
argument must be references, pointers or move-constructible. When a member
function is specified, then the object for which the member function is called
must be a named object, an anonymous object, or a pointer to a named
object. When passing a named object to the tt(async) function template then
copy construction is used to create an object which is passed to the
thread-launcher. When an anonymous object is passed to the tt(async) function
template then move construction is used to pass the anonymous object to the
thread launcher. When the thread itself starts another move construction is
used to create an object for the duration of the sub-thread. When a pointer to
an object is passed, the sub-thread uses the object referred to by the
pointer, and neither copy- nor move-construction is required. However, when
using a pointer to an object the programmer should make sure that the
object's lifetime exceeds the duration of the thread (note that this is not
automatically guaranteed, as the asynchronous task may not start before the
future's tt(get) member is called.
    



The first tt(async) function is an abbreviated call for the second tt(async)
function, when passing it tt(launch::deferred) as its first argument.

Both functions create a shared state which can be obtained from the returned
tt(future) object.

The first tt(async) function and the second function, when
specifying tt(launch::deferred) call the function tt(fun). The returned
shared state is only available after the function tt(fun) has
returned.

However, when just calling tt(assign) it is likely that tt(fun) doesn't
return. The tt(launch::deferred) policy allows tt(async) to defer evaluation
until the implementation is ready for it, or the program explicitly asks for
it. Consider the following program:
        verbinclude(-ans4 examples/async1.cc)
    Although tt(async) is called in line 14, when the program is run 
the output doesn't show tt(fun's) output line:
        verb(
    First async call starts
    First async call ends
    Second async call starts
    Second async call ends
        )
    This happens because of tt(lauch::deferred): the system simply defers
tt(fun's) execution until required, which never occurs. But the tt(future)
object that's returned by tt(async) has a member tt(wait). Once tt(wait)
returns the shred state must be available. In other words: tt(fun) must have
finished. Here is what happens when line 14 is changed into
tt(async(fun).wait()): 
        verb(
    First async call starts
        hello from fun
    First async call ends
    Second async call starts
        hello from fun
    Second async call ends
        )
    Evaluation of tt(fun) can thus be controlled to the point where we want
it, maybe even after calling tt(asyncCall), as shown in the next
example. Knowing that the function tt(fun) returns tt(void) 

    
    

    
                — if policy & launch::deferred is non-zero — Stores
            decay_copy(std::forward<F>(f)) and
            decay_copy(std::forward<Args>(args))... in the shared state. These
            copies of f and args constitute a deferred function. Invocation of
            the deferred function evaluates INVOKE (g, xyz) where g is the
            stored value of decay_copy(std::forward<F>(f)) and xyz is the
            stored copy of decay_copy(std::forward<Args>(args)).... The shared
            state is not made ready until the function has completed. 

The
            first call to a function requiring a non-timed wait on an
            asynchronous return object referring to the shared state created
            by this async call to become ready shall invoke the deferred
            function in the thread that called the waiting function; once
            evaluation of INVOKE (g, xyz) begins, the function is no longer
            considered deferred.
                Note: If this policy is specified together with other
            policies, such as when using a policy value of launch::async |
            launch::deferred, implementations should defer invocation or the
            selection of the policy when no more concurrency can be
            effectively exploited.

    The further behavior of the second
            function depends on the policy argument as follows (if more than
            one of these conditions applies, the implementation may choose any
            of the corresponding policies): 
                — if policy & launch::async is non-zero — executes INVOKE
            (decay_copy(std::forward<F>(f)),
            decay_copy(std::forward<Args>(args))...) (20.8.2, 30.3.1.2) as if
            in a new thread of execution represented by a thread object with
            the calls to decay_copy() being evaluated in the thread that
            called async. Any return value is stored as the result in the
            shared state. Any exception propagated from the execution of
            INVOKE (decay_copy(std::forward<F>(f)),
            decay_copy(std::forward<Args>(args))...) is stored as the
            exceptional result in the shared state. The thread object is
            stored in the shared state and affects the behavior of any
            asynchronous return objects that reference that state.




    Returns: An object of type future<typename result_of<F(Args...)>:type>
            that refers to the shared state created by this call to async. 
    Synchronization: Regardless of the provided policy argument,
            — the invocation of async synchronizes with (1.10) the invocation
                of f.  
                Note: This statement applies even when the corresponding future
                object is moved to another thread. 
        and
            — the completion of the function f is sequenced before (1.10) the
            shared state is made ready. 
                Note: f might not be called at all, so its completion might
                never happen.
        If policy & launch::async is non-zero,
            — a call to a waiting function on an asynchronous return object
            that shares the shared state created by this async call shall
            block until the associated thread has completed, as if joined
            (30.3.1.5); 
            — the join() on the created thread object synchronizes with (1.10)
            the return from the first function that successfully detects the
            ready status of the shared state or with the return from the last
            function that releases the shared state returns, whichever happens
            first. [Editor’s note: N3196 changes the following sentence as
            indicated. N3188 removes the sentence. Please pick one.] If the
            invocation is deferred, the completion of the invocation of the
            deferred function synchronizes with the successful return from a
            call to a waiting function on the shared state. 
    Throws: system_error if policy is launch::async and the implementation is
            unable to start a new thread. 
    Error conditions:
        — resource_unavailable_try_again — if policy is launch::async and the
            system is unable to start a new thread. 
    Remarks: The first signature shall not participate in overload resolution
            if decay<F>::type is std::launch. 
    Example:
        int work1(int value);
        int work2(int value);
        int work(int value) {
        auto handle = std::async([=]{ return work2(value); });
        int tmp = work1(value);
        return tmp + handle.get();
        // #1

    Note: Line #1 might not result in concurrency because the async call uses
            the default policy, which may use launch::deferred, in which case
            the lambda might not be invoked until the get() call; in that
            case, work1 and work2 are called on the same thread and there is
            no concurrency.  

