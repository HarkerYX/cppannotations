In addition to tt(std::package_task) and tt(std::async) the class template
hi(promise)tt(std::promise) can be used to exchange results among different
threads. A value or exception may be assigned to a tt(promise) in one thread,
allowing another thread to access the tt(future) associated with the
tt(promise) at some later point in time.

Before using the class template tt(promise) the tthi(future) header file
must be included.

A tt(promise) is useful in cases where a tt(future) is required containing a
specific result, but there's no function available or necessary to produce the
necessary result. An example in which this situation is encountered is
developed in the next section, where commands, read from the standard input
stream, are processed by a thread distributing the commands over a `pool' of
worker threads, each doing some `real work'. The results of the worker threads
are received and processed by the main thread until the main thread receives a
result containing the text tt(done). On the one hand this protocol uses
tt(packaged_tasks) to obtain the results of the real work done by the worker
threads; on the other hand it uses a tt(std::promise) object to create the
final tt(future), containing the tt(done) result. The main thread ends once it
receives that tt(done) result.

Here is the class tt(promise)'s interface. Note that the class
tt(promise) is a class template: its template type parameter tt(ReturnType)
specifies the template type parameter of the tt(std::future) that can be
retrieved from the tt(promise) object. 

Constructors and destructor:
    itemization(
    ittq(promise())
       (The default constructor constructs a tt(promise) object containing a
        shared state. The shared state may be returned by the member
        tt(get_future) (see below), but that future has not yet been made
        ready.)

    ittq(promise(promise &&tmp) noexcept)
       (The move constructor constructs a tt(promise) object, transferring
        the ownership of tt(tmp's) shared state to the newly constructed
        object. After the object has been constructed, tt(tmp) no longer
        contains a shared state.)

    ittq(~promise())
       (The object's shared state (if any) is abandoned)
    )

Member functions:
    itemization(
    ittq(std::future<ReturnType> get_future())
       (A tt(std::future) object haring the current object's shared state is
        returned. A tt(future_error) exception is thrown upon error,
        containing 
       itemization(
       itt(future_already_retrieved) if tt(get_future) was already called on a
            tt(packaged_task) object containing the same shared state as the
            current object;
        itt(no_state) if the current object has no shared state.
       ).
       Note: Any tt(futures) that share the object's shared state will be able
        to access the result returned by the object's task.)


    ittq(promise &operator=(promise &&rhs) noexcept)
       (The move assignment operator first releases the current object's
        shared state (if available), after which the current object and
        tt(tmp) are swapped;)

    ittq(void promise<void>::set_value())
       (See below, at the last tt(set_value) member's description)

    ittq(void set_value(ReturnType &&value))
       (See below, at the last tt(set_value) member's description)

    ittq(void set_value(ReturnType const &value))
       (See below, at the last tt(set_value) member's description)
    ittq(void set_value(ReturnType &value))
       (The argument (tt(value)) is atomically stored in the shared state,
        which is then also made ready. A tt(future_error) exception is thrown
        upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state.
       )
       Alternatively, any exception thrown by tt(value)'s move or copy
        constructor may be thrown.)
    COMMENT(
       When multiple threads use tt(set_value) and tt(set_exception) then
        calls to set_value and set_exception on a single tt(promise) object
        are serialized, and they synchronize and serialize with other
        functions through the referred shared state. 

        Not overly important? When multiple set_value calls occur then a
        promise_already_satisfied is thrown.
    END) 

    ittq(void set_exception(std::exception_ptr ptr))
       (The exception pointer ptr is atomically stored in the shared state,
        making that state ready. A tt(future_error) exception is thrown
        upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state.
       ))

    ittq(void set_exception_at_thread_exit(exception_ptr ptr))
       (The exception pointer tt(ptr) is stored in the shared state without
        immediately making that state ready. The state becomes ready when the
        current thread exits, once all objects of thread storage duration
        which are associated with the ending thread have been destroyed.  A
        tt(future_error) exception is thrown upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state.
       ))


    ittq(void set_value_at_thread_exit())
       (See below, at the last tt(set_value_at_thread_exit) member's
        description)

    ittq(void set_value_at_thread_exit(ReturnType &&value))
       (See below, at the last tt(set_value_at_thread_exit) member's
        description)

    ittq(void set_value_at_thread_exit(ReturnType const &value))
       (See below, at the last tt(set_value_at_thread_exit) member's
        description)

    ittq(void set_value_at_thread_exit(ReturnType &value))
       (Stores tt(value) in the shared state without immediately making that
        state ready.  The state becomes ready when the current thread exits,
        once all objects of thread storage duration which are associated with
        the ending thread have been destroyed.  A tt(future_error) exception
        is thrown upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state.
       ))

    ittq(void swap(promise& other) noexcept)
       (The shared states (if any) of the current object and tt(other) are
        exchanged.)
    )

The following non-member (free) function operating on tt(promise) objects is
available:
    itemization(
    ittq(void swap(promise<ReturnType> &lhs, promise<ReturnType> &rhs)
        noexcept) 
       (Calls tt(lhs.swap(rhs)))
    )
