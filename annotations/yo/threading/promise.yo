In addition to tt(std::package_task) and tt(std::async) the class template
hi(promise)tt(std::promise) can be used to exchange results among different
threads. A value or exception may be assigned to a tt(promise) in one thread,
allowing another thread to access the tt(future) associated with the
tt(promise) at some later point in time.

Before using the class template tt(promise) the tthi(future) header file
must be included.

A tt(promise) is useful in cases where a tt(future) is required containing a
specific result, but there's no function available or necessary to produce the
result. 
COMMENT(
It could be used, e.g., when implementing a multi-threaded matrix
multiplication. Each element of the resulting product matrix is computed as
the inner product of two vectors: the function computing the inner product can
be executed as a separate thread, `promising' to compute the requested value. 
The final matrix can be constructed from the computed inner products in yet
another thread, returning the matrix once all its elements have been
collected.
END)    

Here is the class tt(promise)'s interface. Note that the class
tt(promise) is a class template: its template type parameter tt(ReturnType)
specifies the template type parameter of the tt(std::future) that can be
retrieved from the tt(promise) object. 

Constructors and destructor:
    itemization(
    ittq(promise())
       (The default constructor constructs a tt(promise) object containing a
        shared state. The shared state may be returned by the member
        tt(get_future) (see below), but that future has not yet been made
        ready.)

    ittq(promise(promise &&tmp) noexcept)
       (The move constructor constructs a tt(promise) object, transferring
        the ownership of tt(tmp's) shared state to the newly constructed
        object. After the object has been constructed, tt(tmp) no longer
        contains a shared state.)

    ittq(~promise())
       (The object's shared state (if any) is abandoned)
    )

Member functions:
    itemization(
    ittq(std::future<ReturnType> get_future())
       (A tt(std::future) object sharing the current object's shared state is
        returned. A tt(future_error) exception is thrown upon error,
        containing 
       itemization(
       itt(future_already_retrieved) if tt(get_future) was already called on a
            tt(packaged_task) object containing the same shared state as the
            current object;
        itt(no_state) if the current object has no shared state.
       )
       Note: Any tt(futures) that share the object's shared state may
        access the result returned by the object's task;)

    ittq(promise &operator=(promise &&rhs) noexcept)
       (The move assignment operator first releases the current object's
        shared state (if available), after which the current object and
        tt(tmp) are swapped;)

    ittq(void promise<void>::set_value())
       (See below, at the last tt(set_value) member's description;)

    ittq(void set_value(ReturnType &&value))
       (See below, at the last tt(set_value) member's description;)

    ittq(void set_value(ReturnType const &value))
       (See the next member function's description;)

    ittq(void set_value(ReturnType &value))
       (The argument (tt(value)) is atomically stored in the shared state,
        which is then also made ready. A tt(future_error) exception is thrown
        upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state.
       )
       Alternatively, any exception thrown by tt(value)'s move or copy
        constructor may be thrown;)
    COMMENT(
       When multiple threads use tt(set_value) and tt(set_exception) then
        calls to set_value and set_exception on a single tt(promise) object
        are serialized, and they synchronize and serialize with other
        functions through the referred shared state. 

        Not overly important? When multiple set_value calls occur then a
        promise_already_satisfied is thrown.
    END) 

    ittq(void set_exception(std::exception_ptr ptr))
       (The exception pointer ptr is atomically stored in the shared state,
        making that state ready. A tt(future_error) exception is thrown
        upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state;
       ))

    ittq(void set_exception_at_thread_exit(exception_ptr ptr))
       (The exception pointer tt(ptr) is stored in the shared state without
        immediately making that state ready. The state becomes ready when the
        current thread exits, once all objects of thread storage duration
        which are associated with the ending thread have been destroyed.  A
        tt(future_error) exception is thrown upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state;
       ))


    ittq(void set_value_at_thread_exit())
       (See below, at the last tt(set_value_at_thread_exit) member's
        description;)

    ittq(void set_value_at_thread_exit(ReturnType &&value))
       (See below, at the last tt(set_value_at_thread_exit) member's
        description;)

    ittq(void set_value_at_thread_exit(ReturnType const &value))
       (See the next tt(set_value_at_thread_exit) member's
        description;)

    ittq(void set_value_at_thread_exit(ReturnType &value))
       (Stores tt(value) in the shared state without immediately making that
        state ready.  The state becomes ready when the current thread exits,
        once all objects of thread storage duration which are associated with
        the ending thread have been destroyed.  A tt(future_error) exception
        is thrown upon error, containing
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state;
       ))

    ittq(void swap(promise& other) noexcept)
       (The shared states (if any) of the current object and tt(other) are
        exchanged.)
    )

The following non-member (free) function operating on tt(promise) objects is
available:
    itemization(
    ittq(void swap(promise<ReturnType> &lhs, promise<ReturnType> &rhs)
        noexcept) 
       (Calls tt(lhs.swap(rhs)))
    )
