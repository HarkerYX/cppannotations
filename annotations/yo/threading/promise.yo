In addition to tt(std::package_task) and tt(std::async) the class template
hi(promise)tt(std::promise) can be used to exchange results among different
threads. A value or exception may be assigned to a tt(promise) in one thread,
allowing another thread to access the tt(future) associated with the
tt(promise) at some later point in time.

Before using the class template tt(promise) the tthi(future) header file
must be included.


Class template std::promise

template <class R>
class promise 
{
    public:
        promise();
        template <class Allocator>
        promise(allocator_arg_t, const Allocator& a);
        promise(promise&& rhs) noexcept;
        promise(const promise& rhs) = delete;
        ~promise();

        // assignment
        promise& operator=(promise&& rhs) noexcept;
        promise& operator=(const promise& rhs) = delete;
        void swap(promise& other) noexcept;

        // retrieving the result
        future<R> get_future();

        // setting the result
        void set_value(see below);
        void set_exception(exception_ptr p);

        // setting the result with deferred notification
        void set_value_at_thread_exit(const R& r);
        void set_value_at_thread_exit(see below);
        void set_exception_at_thread_exit(exception_ptr p);
};

template <class R>
void swap(promise<R>& x, promise<R>& y);

template <class R, class Alloc>
struct uses_allocator<promise<R>, Alloc>;

The implementation shall provide the template promise and two specializations,
promise<R&> and promise<void>.  These differ only in the argument type of the
member function set_value, as set out in its description, below.

template <class R, class Alloc>
struct uses_allocator<promise<R>, Alloc>
: true_type { };

Requires: Alloc shall be an Allocator (17.6.3.5).

promise();

template <class Allocator>
promise(allocator_arg_t, const Allocator& a);

Effects: constructs a promise object and an shared state. The second
constructor uses the allocator a to allocate memory for the shared state.

promise(promise&& rhs) noexcept;

    Effects: constructs a new promise object and transfers ownership of the
shared state of rhs (if any) to the newly-constructed object.

    Postcondition: rhs has no shared state.

~promise();

    Effects: Abandons any shared state (30.6.4).

promise& operator=(promise&& rhs) noexcept;

    Effects: Abandons any shared state (30.6.4) and then as if
        promise(std::move(rhs)).swap(*this).

    Returns: *this.

void swap(promise& other) noexcept;

    Effects: Exchanges the shared state of *this and other.

    Postcondition: *this has the shared state (if any) that other had prior to
        the call to swap. other has the shared state (if any) that *this had
        prior to the call to swap.

future<R> get_future();

    Returns: A future<R> object with the same shared state as *this.
    Throws: future_error if *this has no shared state or if get_future has
        already been called on a promise with the same shared state as *this. 
    Error conditions:
        — future_already_retrieved if get_future has already been called on a
            promise with the same shared state as *this.
        — no_state if *this has no shared state.

void promise::set_value(const R& r);
void promise::set_value(R&& r);
void promise<R&>::set_value(R& r);
void promise<void>::set_value();

    Effects: atomically stores the value r in the shared state and makes that
        state ready (30.6.4). 
    Throws:
        — future_error if its shared state already has a stored value or
            exception, or 
        — for the first version, any exception thrown by the copy constructor
            of R, or 
        — for the second version, any exception thrown by the move constructor
            of R. 
    Error conditions:
        — promise_already_satisfied if its shared state already has a stored
            value or exception. 
        — no_state if *this has no shared state.
    Synchronization: calls to set_value and set_exception on a single promise
            object are serialized. 

Note: And they synchronize and serialize with other functions through the
      referred shared state. 

void set_exception(exception_ptr p);

    Effects: atomically stores the exception pointer p in the shared state and
            makes that state ready (30.6.4). 
    Throws: future_error if its shared state already has a stored value or
            exception. 
    Error conditions:
        — promise_already_satisfied if its shared state already has a stored
            value or exception. 
        — no_state if *this has no shared state.
    Synchronization: calls to set_value and set_exception on a single promise
            object are serialized. 

Note: And they synchronize and serialize with other functions through the
referred shared state. 

void promise::set_value_at_thread_exit(const R& r);
void promise::set_value_at_thread_exit(R&& r);
void promise<R&>::set_value_at_thread_exit(R& r);
void promise<void>::set_value_at_thread_exit();

    Effects: Stores the value r in the shared state without making that state
            ready immediately. Schedules that state to be made ready when the
            current thread exits, after all objects of thread storage duration
            associated with the current thread have been destroyed.
    Throws: future_error if an error condition occurs.
    Error conditions:
        — promise_already_satisfied if its shared state already has a stored
            value or exception. 
        — no_state if *this has no shared state.

void promise::set_exception_at_thread_exit(exception_ptr p);

    Effects: Stores the exception pointer p in the shared state without making
            that state ready immediately. Schedules that state to be made
            ready when the current thread exits, after all objects of thread
            storage duration associated with the current thread have been
            destroyed.
    Throws: future_error if an error condition occurs.
    Error conditions:
        — promise_already_satisfied if its shared state already has a stored
            value or exception. 
        — no_state if *this has no shared state.

template <class R>
void swap(promise<R>& x, promise<R>& y);

    Effects: x.swap(y).
