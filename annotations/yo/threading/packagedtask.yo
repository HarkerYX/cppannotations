The class template hi(packaged_task)tt(std::packaged_task) allows a thread to
package a function or functor, which is then passed to another thread, which
calls the function, passing it its arguments (if any). Following the
function's call the packaged task's future is ready, allowing the first thread
to access the results produced by the function. Thus, functions and the
results of function calls can be transferred between threads.

Before using the class template tt(packaged_task) the tthi(future) header file
must be included.
 
Before covering the class's interface, let's first look at an example to get
an idea about how a tt(packaged_task) can be used. Remember that the essence
of tt(packaged_task) is that there is a thread preparing (packaging) a task
for another thread to complete, with the preparing thread at some point
needing the result of the completed task. Here is a small program implementing
precisely that (assuming all required headers as well as tt(using namespace
std) have been specified):
    verbinsert(-ans4 examples/packageddemo.cc)
    itemization(
    it() Lines 1-3 define the variables used for synchronization;
    it() Line 4 defines a tt(packaged_task: task) is initialized with a
        function (or functor) expecting a tt(string), returning a tt(size_t);
    it() Lines 6-9 and 11-15 define such functions. tt(size_t length) (line
        6) simply returns the length of its tt(str) parameter; tt(size_t file)
        (line 11) returns the number of lines in the file whose name is passed
        to the function (assuming that no lines exceed 1000 characters);
    it() Lines 20-31 define the function tt(void run), defining the actions of
        the second thread (it is started as a detached thread at line 35). In
        an continuous loop it waits until it obtains a lock on
        tt(commandMutex) and tt(command) is no longer empty. Then, at line 28,
        it passes tt(command) to the tt(packaged_task `task'). By itself this
        is not identical to calling the packaged_task's function, but
        eventually this function will be called. At this point the
        tt(packaged_task) receives its function's arguments, which it
        eventually will pass on to its configured function. Finally, at line
        29 it clears tt(command), thus preparing itself for the next request.
    it() Lines 33-53 define tt(main):
        itemization(
        it() First, at line 35 an anonymous detached thread executing tt(run)
            is started. It immediately obtains the lock of tt(commandMutex),
            but noticing tt(command) is empty, it waits, releasing the lock.
        )
        Then the main loop starts (lines 37-52):
        itemization(
        it() The main thread reads commands from the standard input until an
            empty or no line is received (lines 39-41).
        it() By convention the line's first letter specifies a request, and
            the remaining characters (which are copied to tt(command), lines
            42-45) define the contents of the request. 
        it() The tt(packaged_task) is constructed next (line 46), configuring
            the tt(packaged_task) with either the tt(length) or the tt(file)
            function. 
        it() Then, in line 49 the results, stored in a tt(future), are
            retrieved. Although at this point the tt(future) might not be
            ready, the tt(future) object itself em(is), and it is simply
            returned in tt(result).
        it() Now we're ready to inform the second thread that it can use
            tt(command): the thread is notified in line 50.
        )
       Anything may happen thereafter: the main thread may do as it pleases,
        but eventually it will need the results produced by the second thread.
       itemization(
        it() The main thread obtains the results by calling tt(result.get())
            in line 51. If, by this time, tt(result) doesn't yet contain the
            results produced by the tt(packaged_task) it blocks; otherwise the
            result (an tt(int) as per the tt(int (std::string)
            packaged_task's) template type parameter) is already available and
            can immediately be used.
        )
    )
    Now that we've seen an example of a program using a tt(packaged_task),
let's have a look at its interface. Note that the class tt(packaged_task) is a
class template: its template type parameter specifies the prototype of a
function or function object implementing the task performed by the
tt(packaged_task) object.

Constructors and destructor:
    itemization(
    ittq(packaged_task() noexcept)
       (The default constructor constructs a tt(packaged_task) object which is
        not associated with a function or shared state;)

    ittq(explicit packaged_task(ReturnType(Args...) &&function))
       (A tt(packaged_task) is constructed for a function or function object
        expecting arguments of types tt(Args...), and returning a value of
        type tt(ReturnType). The tt(packaged_task) class template specifies
        tt(ReturnType (Args...)) as its template type parameter. The
        constructed object contains a shared state, and a (move constructed)
        copy of tt(function).

       Optionally an tt(Allocator) may be specified as second template type
        parameter, in which case first two arguments are
        hi(allocator_arg_t)tt(std::allocator_arg_t, Allocator const
        &alloc). The type tt(std::allocator_arg_t) is a type introduced to
        disambiguate constructor selections, and can simply be specified as
        tt(std::allocator_arg_t()).

        This constructor may throw a tt(std::bad_alloc) exception or
        exceptions thrown by tt(function's) copy or move constructors)

    ittq(packaged_task(packaged_task &&tmp) noexcept)
       (The move constructor moves  any existing shared state from tt(tmp) to
        the newly constructed object, removing the shared state from tt(tmp).)

    ittq(~packaged_task())
       (The object's shared state (if any) is abandoned)
    )

Member functions:
    itemization(
    ithtq(get_future)(future<ReturnType> get_future())
       (A tt(std::future) object haring the current object's shared state is
        returned. A tt(future_error) exception is thrown upon error,
        containing 
       itemization(
       itt(future_already_retrieved) if tt(get_future) was already called on a
            tt(packaged_task) object containing the same shared state as the
            current object;
        itt(no_state) if the current object has no shared state.
       ).
       Note: Any tt(futures) that share the object's shared state will be able
        to access the result returned by the object's task.)

    ittq(void make_ready_at_thread_exit(Args... args))
       (Calls tt(void operator()(Args... args)) (see below) when the current
        thread exits, once all objects of thread storage duration associated
        with the current thread have been destroyed.)

    ittq(packaged_task &operator=(packaged_task &&tmp))
       (The move assignment operator first releases the current object's
        shared state (if available), after which the current object and
        tt(tmp) are swapped;)

    ittq(void operator()(Args... args)
       (The tt(args) arguments are perfectly forwarded to the current object's
        stored task. When the stored task returns its return value is stored
        in the current object's shared state. Otherwise any exception thrown
        by the task is stored in the object's shared state. Following this the
        object's shared state is made ready, and any threads blocked in a
        function waiting for the object's shared state to become ready are
        unblocked. A tt(future_error) exception is thrown upon error,
        containing 
       itemization(
       itt(promise_already_satisfied) if the shared state has already been
            made ready;
        itt(no_state) if the current object does not have any shared state.
       )
       A successful call to this member synchronizes with a call to any member
        function of a tt((shared_)future) object that shares the current
        object's shared state. Completing the call of the stored task and the
        storage of the result or exception into the shared state synchronizes
        with the successful return from any member function that detects that
        the state is set to ready.))
    
    ittq(void reset())
       (Abandons any available shared state, initializing the current object
        to tt(packaged_task(std::move(funct))), where tt(funct) is the
        object's stored task. This member may throw the following exceptions:
       itemization(
       itt(bad_alloc) if memory for the new shared state could not be
            allocated;
        it() any exception thrown by the move constructor of the task stored in
                the shared state;   
        itt(future_error) with a tt(no_state) error condition if the current
            object contains no shared state.
       ))

    ittq(void swap(packaged_task &other) noexcept)
       (The shared states and stored tasks of the current object  and other
        are swapped.) 

    ittq(bool valid() const noexcept)
       (Returns tt(true) if the current object contains a shared state,
        otherwise tt(false) is returned;)
    )

The following non-member (free) function operating on tt(packaged_task)
objects is available:
    itemization(
    ittq(void swap(packaged_task<ReturnType(Args...)> &lhs, 
                   packaged_task<ReturnType(Args...)> &rhs) noexcept)
       (Calls tt(lhs.swap(rhs)))
    )

COMMENT(
    template <class R, class Alloc>
    struct uses_allocator<packaged_task<R>, Alloc>;

    Requires: Alloc shall be an Allocator (17.6.3.5).
END)


