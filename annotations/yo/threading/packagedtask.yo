The class template hi(packaged_task)tt(std::packaged_task) allows a thread to
package a function or functor, which is then passed to another thread, which
calls the function, passing it its arguments (if any). Following the
function's call the packaged task's future is ready, allowing the first thread
to access the results produced by the function. Thus, functions and the
results of function calls can be transferred between threads.

Before using the class template tt(packaged_task) the tthi(future) header file
must be included.
 
Any futures
that share the shared state will then be able to access the stored result.




template<class> class packaged_task; // undefined

template<class R, class... ArgTypes>
class packaged_task<R(ArgTypes...)> 
{
    public:
    typedef R result_type;
    // construction and destruction
    packaged_task() noexcept;
    template <class F>
    explicit packaged_task(F f);
    template <class F, class Allocator>
    explicit packaged_task(allocator_arg_t, const Allocator& a, F f);
    explicit packaged_task(R(*f)(ArgTypes...));
    template <class F>
    explicit packaged_task(F&& f);
    template <class F, class Allocator>
    explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);
    ~packaged_task();

    // no copy
    packaged_task(packaged_task&) = delete;
    packaged_task& operator=(packaged_task&) = delete;

    // move support
    packaged_task(packaged_task&& other) noexcept;
    packaged_task& operator=(packaged_task&& other);

    void swap(packaged_task& other) noexcept;
    bool valid() const noexcept;

    // result retrieval
    future<R> get_future();

    // execution
    void operator()(ArgTypes... );
    void make_ready_at_thread_exit(ArgTypes...);
    void reset();
};

Before covering the class's interface, let's first look at an example to get
an idea about how a tt(packaged_task) can be used. Remember that the essence
of tt(packaged_task) is that there is a thread preparing (packaging) a task
for another thread to complete, with the preparing thread at some point
needing the result of the completed task. Here is a small program implementing
precisely that (assuming all required headers as well as tt(using namespace
std) have been specified):
    verbinsert(-ans4 examples/packageddemo.cc)
    itemization(
    it() Lines 1-3 define the variables used for synchronization;
    it() Line 4 defines a tt(packaged_task: task) is initialized with a
        function (or functor) expecting a tt(string), returning a tt(size_t);
    it() Lines 6-9 and 11-15 define such functions. tt(size_t length) (line
        6) simply returns the length of its tt(str) parameter; tt(size_t file)
        (line 11) returns the number of lines in the file whose name is passed
        to the function (assuming that no lines exceed 1000 characters);
    it() Lines 20-31 define the function tt(void run), defining the actions of
        the second thread (it is started as a detached thread at line 35). In
        an continuous loop it waits until it obtains a lock on
        tt(commandMutex) and tt(command) is no longer empty. Then, at line 28,
        it passes tt(command) to the tt(packaged_task `task'). By itself this
        is not identical to calling the packaged_task's function, but
        eventually this function will be called. At this point the
        tt(packaged_task) receives its function's arguments, which it
        eventually will pass on to its configured function. Finally, at line
        29 it clears tt(command), thus preparing itself for the next request.
    it() Lines 33-53 define tt(main). First, at line 35 an anonymous detached
        thread executing tt(run) is started. It immediately obtains the lock
        of tt(commandMutex), but noticing tt(command) is empty, it waits,
        releasing the lock. Then in a loop (lines 37-52) it reads commands
        from the standard input until an empty or no line is received (lines
        39-41). By convention the line's first letter specifies a request, and
        the remaining characters (which are copied to tt(command) (lines
        42-45) the contents of the request. The 

packaged_task() noexcept;

    Effects: constructs a packaged_task object with no shared state and no
                stored task. 

template <class F>
packaged_task(F f);

template <class F, class Allocator>
explicit packaged_task(allocator_arg_t, const Allocator& a, F f);

packaged_task(R(*f)(ArgTypes...));

template <class F>
packaged_task(F&& f);

template <class F, class Allocator>
explicit packaged_task(allocator_arg_t, const Allocator& a, F&& f);

    Requires: INVOKE (f, t1, t2, ..., tN, R), where t1, t2, ..., tN are values
                of the corresponding types in ArgTypes..., shall be a valid
                expression. Invoking a copy of f shall behave the same as
                invoking f.
    Effects: constructs a new packaged_task object with an shared state and
                stores a copy of f as the object’s stored task. The
                constructors that take an Allocator argument use it to
                allocate memory needed to store the internal data structures. 
    Throws: any exceptions thrown by the copy or move constructor of f, or
                std::bad_alloc if memory for the internal data structures
                could not be allocated. packaged_task(packaged_task&& other)
                noexcept;
    Effects: constructs a new packaged_task object and transfers ownership of
                other’s shared state to *this, leaving other with no shared
                state.
    Postcondition: other has no shared state.

packaged_task& operator=(packaged_task&& other);

    Effects:
        — releases any shared state (30.6.4).
        — packaged_task(other).swap(*this).

~packaged_task();

    Effects: Abandons any shared state. (30.6.4).

void swap(packaged_task& other) noexcept;

    Effects: exchanges the shared states and stored tasks of *this and other.
    Postcondition: *this has the same shared state and stored task (if any) as
                other prior to the call to swap. other has the same shared
                state and stored task (if any) as *this prior to the call to
                swap. 

bool valid() const noexcept;

    Returns: true only if *this has an shared state.

future<R> get_future();

    Returns: A future object that shares the same shared state as *this.
    Throws: a future_error object if an error occurs.
    Error conditions:
        — future_already_retrieved if get_future has already been called on a
                packaged_task object with the same shared state as *this. 
        — no_state if *this has no shared state.

void operator()(ArgTypes... args);
    Effects: INVOKE (f, t1, t2, ..., tN, R), where f is the stored task of
                *this and t1, t2, ..., tN are the values in args.... If the
                task returns normally, the return value is stored as the
                asynchronous result in the shared state of *this, otherwise
                the exception thrown by the task is stored. The shared state
                of *this is made ready, and any threads blocked in a function
                waiting for the shared state of *this to become ready are
                unblocked.
    Throws: a future_error exception object if there is no shared state or the
                stored task has already been invoked. 
    Error conditions:
        — promise_already_satisfied if the shared state is already ready.
        — no_state if *this has no shared state.
    Synchronization: a successful call to operator() synchronizes with (1.10)
                a call to any member function of a future or shared_future
                object that shares the shared state of *this. The completion
                of the invocation of the stored task and the storage of the
                result (whether normal or exceptional) into the shared state
                synchronizes with (1.10) the successful return from any member
                function that detects that the state is set to ready. 
                    Note: operator() synchronizes and serializes with other
                functions through the shared state. 

void make_ready_at_thread_exit(ArgTypes... args);
    Effects: INVOKE (f, t1, t2, ..., tN, R), where f is the stored task and
                t1, t2, ..., tN are the values in args.... If the task returns
                normally, the return value is stored as the asynchronous
                result in the shared state of *this, otherwise the exception
                thrown by the task is stored. In either case, this shall be
                done without making that state ready (30.6.4)
                immediately. Schedules the shared state to be made ready when
                the current thread exits, after all objects of thread storage
                duration associated with the current thread have been
                destroyed.
    Throws: future_error if an error condition occurs.
    Error conditions:
        — promise_already_satisfied if the shared state already has a stored
                value or exception. 
        — no_state if *this has no shared state.

void reset();

    Effects: as if *this = packaged_task(std::move(f)), where f is the task
                stored in *this.  
               Note: This constructs a new shared state for *this. The old
                state is abandoned (30.6.4).  
    Throws:
        — bad_alloc if memory for the new shared state could not be allocated.
        — any exception thrown by the move constructor of the task stored in
                the shared state. 
        — future_error with an error condition of no_state if *this has no
                shared state. 30.6.9.2

packaged_task globals:

template <class R, class... ArgTypes>
void swap(packaged_task<R(ArgTypes...)>& x, packaged_task<R(ArgTypes...)>& y)
          noexcept; 

    Effects: x.swap(y)

template <class R, class Alloc>
struct uses_allocator<packaged_task<R>, Alloc>;

    Requires: Alloc shall be an Allocator (17.6.3.5).

