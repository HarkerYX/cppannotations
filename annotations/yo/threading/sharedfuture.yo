When the results of an asynchronous task are made available through a 
tt(std::future) object, then only one instance of that tt(std::future) object
can exist. On the other hand, multiple instances of 
    hi(shared_future)tt(std::shared_future)
objects may exist, each referring to the same results of an executed
asynchronous task. 

Before using the class tt(std::shared_future) the tthi(future) header file
must be included.

When using multiple instances of tt(shared_future) objects, the results of the
associated asynchronous task become ready (available) at exactly the same
moment in time. 

When multiple threads access the results stored in a single tt(future) object,
access to these results must normally be synchronized using mutexes. However,
when multiple threads access a single tt(shared_future) object, then each of
these threads may access the results of the asynchronously executed task
without further synchronization. The relationship between the classes
tt(future) and tt(shared_future) resembles the relationship between the
classes tt(unique_ptr) and tt(shared_ptr): there can only be one instance of a
tt(unique_pointer), pointing to data, whereas there can be many instances of a
tt(shared_pointer), each pointing to the same data.


The effect of calling any member function other than the destructor, the
move-assignment operator, or valid() on a shared_future object for which
valid() == false is undefined.

template <class R>
class shared_future 
{
    public:
        shared_future() noexcept;
        shared_future(const shared_future& rhs);
        shared_future(future<R>&&) noexcept;
        shared_future(shared_future&& rhs) noexcept;

        ~shared_future();

        shared_future& operator=(const shared_future& rhs);
        shared_future& operator=(shared_future&& rhs);

        // retrieving the value
        see below get() const;

        // functions to check state
        bool valid() const;
        void wait() const;
        template <class Rep, class Period>
        future_status wait_for(const chrono::duration<Rep, Period>& rel_time)
                                                                        const; 
        template <class Clock, class Duration>
        future_status wait_until(const chrono::time_point<Clock, Duration>&
                                abs_time) const; 
};




In this section the members of the class template tt(shared_future) are
described. 

? tt(Shared_future) objects are commonly initialized by providing an
? anonymous tt(shared_future) object returned by factory functions. Standard
? available
?     COMMENT(
?         KLOPT DE VOLGENDE REGEL WEL? 
?     )
? factory functions are tt(std::async, std::promise, and std::packaged_task),
? which are introduced in upcoming sections. Examples of the use of
? tt(std::future) objects are provided in those sections.

The class tt(shared_future) has the following constructors:
    itemization(
    itt(shared_future() noexcept)
        quote(an empty tt(shared_future) object is constructed that does not
            refer to shared results. After using this constructor the object's
            tt(valid) member returns tt(false).)

    itt(shared_future(shared_future const &other))
        quote(a tt(shared_future) object is constructed that refers to the
            same results as tt(other) (if any). After using this constructor
            the object's tt(valid) member returns the same value as
            tt(other.valid()).)

    itt(shared_future(future<Result> &&tmp) noexcept)
        quote( Effects: move constructs a shared_future object that refers to
            the results that was originally referred to by tt(tmp) (if
            any). After using this constructor the object's tt(valid) member
            returns the same value as tt(tmp.valid()) returned prior to the
            constructor invocation, and tt(tmp.valid()) returns tt(false).)
    )

The class's destructor destroys the tt(shared_future) object for which it is
called. If the object for which the destructor is called is the last
tt(shared_future) object, and no tt(std::promise) or
tt(std::packaged_task) is associated with the results associated
with the current object, then the results are also destroyed.

tt(Std::shared_future) provides the following members:
    itemization(
    itt(shared_future& operator=(shared_future &&tmp))
        quote(The move assignment operator releases the current opject's
            shared results, and move assigns tt(tmp)'s results to the current
            object. After calling the move assignment operator the current
            object's tt(valid) member returns the same value as
            tt(tmp.valid()) returned prior to the
            invocation of the move assignment operator, and tt(tmp.valid())
            returns tt(false).)

    itt(shared_future& operator=(shared_future const &rhs))
        quote(The assignment operator releases the current opject's
            shared results, and tt(rhs)'s results are shared with the current
            object. After calling the assignment operator the current
            object's tt(valid) member returns the same value as
            tt(tmp.valid()).)

    itt(Result const &shared_future::get() const)
        quote((Specializations for tt(shared_future<Result &>) and
            tt(shared_future<void>) are also available). This member waits
            until the shared results are available, and subsequently returns
            tt(Result const &). Note that access to the data stored in
            tt(Results), accessed through tt(get) is not synchronized. It is
            the responsibility of the programmer to avoid race conditions when
            accessing tt(Result's) data. If tt(Result) holds an exception, it
            is thrown when tt(get) is called.)

    itt(bool valid() const)
        quote(Returns tt(true) if the current object refers to shared results)

    itt(void wait() const)
        quote(Blocks until shared results are available (i.e., the associated
            asynchronous task has produced results.))

    itt(future_status wait_for(const chrono::duration<Rep, Period>& rel_time)
            const)
        quute((The template types tt(Rep) and tt(Period) normally are derived
            by the compiler from the actual tt(rel_time) specification.) If
            the shared results contain a deferred function (cf. section
            ref(ASYNC)) nothing happens. Otherwise tt(wait_for) blocks until
            the results of the associated asynchronous task has produced
            results, or until the
            relative time specified by tt(rel_time) has expired. The member
            returns 
            itemization(
            itt(future_status::deferred) if the shared results contain a
                deferred function;
            itt(future_status::ready) if the shared results are available;
            itt(future_status::timeout) if the function is returning because
                the amount of time specified by tt(rel_time) has expired. 
            ))

    itt(future_status wait_until(const chrono::time_point<Clock, Duration>&
            abs_time) const)
        quote((The template types tt(Clock) and tt(Duration) normally are
            derived by the compiler from the actual tt(abs_time)
            specification.) If the shared results contain a deferred function
            nothing happens. Otherwise tt(wait_until) blocks until the shared
            results are available or until the point in time specified by
            tt(abs_time) has expired. Possible return values are:
           itemization(
            itt(future_status::deferred) if the shared results contain a
                deferred function;
            itt(future_status::ready) if the shared results are available;
            itt(future_status::timeout) if the function is returning because
                the point in time specified by tt(abs_time) has expired. 
            ))
    )
