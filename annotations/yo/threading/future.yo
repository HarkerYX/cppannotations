Class template std::future

Asynchronous providers produce asynchronous return objects which may or may
not share their shared state with other asynchronous return objects. 

Objects of the class template hi(future)tt(std::future) represent asynchronous
return objects which may not share their shared state with other asynchronous
return objects. The class's template type parameter defines the type of the
tt(future) object's result, which may be tt(void) or a reference to a return
type. 

A tt(future's) object result is a value or an exception. The tt(future) object
receives its result through member functions of objects that share the
tt(future) object's shared state.

By default a tt(future) object has no shared state. A tt(future) object
containing a shared state can be created by members of asynchronous providers
(such as a tt(std::promise) (cf. section ref(PROMISE)), or by the move
constructor. In these cases it shares its shared state with the original
asynchronous provider. The class tt(future) does not offer a copy constructor
or overloaded assignment operator.


COMMENT(
Note: Member functions of future do not synchronize with themselves or with
member functions of shared_future.
END)

The class tt(future) has a member tt(bool valid()). If this member returns
tt(false) the tt(future's) destructor and move constructor can safely be
called. When calling other members while tt(valid) returns tt(false) a
hi(future_error)tt(std::future_error) exception is thrown (having the error
condition hi(no_state)tt(future_errc::no_state).



template <class R>
class future 
{
    public:
        shared_future<R> share() &&;

        // retrieving the value
        see below: get();

        // functions to check state
        void wait() const;

        template <class Rep, class Period>
        future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;

        template <class Clock, class Duration>
        future_status wait_until(const chrono::time_point<Clock, Duration>&
                                 abs_time) const; 
};

The class tt(future) offers the following constructors:
    itemization(
    itt(future())
        quote(The default constructor constructs an tt(future) object that
            does not refer to a shared state. Its tt(valid) member returns
            tt(false).)

    itt(future(future &&tmp) noexcept)
        quote (The move constructor is available. Its tt(valid) member 
            returns what tt(tmp.valid()) would haved returned prior to the
            constructor invocation. After calling the move constructor
            tt(tmp.valid()) returns tt(false).)
    )

It offers the following members:
    itemization(
    itt(future &operator=(future &&tmp))
        quote(The move assignment operator grabs the information from the
            tt(tmp) object; following this, tt(tmp.valid()) returns
            tt(false).) 

    itt(shared_future<R> share() &&;

    Returns: shared_future<R>(std::move(*this)).
    Postcondition: valid() == false.

R future::get();
R& future<R&>::get();
void future<void>::get();

    Note: as described above, the template and its two required
            specializations differ only in the return type and return value of
            the member function get. 
    Effects: wait()s until the shared state is ready, then retrieves the value
            stored in the shared state. 
    Returns:
        — future::get() returns the value stored in the object’s shared
            state. If the type of the value is MoveAssignable the returned
            value is moved, otherwise it is copied. 
        — future<R&>::get() returns the reference stored as value in the
            object’s shared state. 
        — future<void>::get() returns nothing.
    Throws: the stored exception, if an exception was stored in the shared
            state.
    Postcondition: valid() == false.

bool valid() const;

    Returns: true only if *this refers to an shared state.

void wait() const;

    Effects: blocks until the shared state is ready.

template <class Rep, class Period>
future_status wait_for(const chrono::duration<Rep, Period>& rel_time) const;

    Effects: none if the shared state contains a deferred function (30.6.8),
            otherwise blocks until the shared state is ready or until the
            relative timeout (30.2.4) specified by rel_time has expired. 
    Returns:
        — future_status::deferred if the shared state contains a deferred
            function. 
        — future_status::ready if the shared state is ready.
        — future_status::timeout if the function is returning because the
            relative timeout (30.2.4) specified by rel_time has expired. 

template <class Clock, class Duration>
future_status wait_until(const chrono::time_point<Clock, Duration>& abs_time)
            const;

    Effects: none if the shared state contains a deferred function (30.6.8),
            otherwise blocks until the shared state is ready or until the
            absolute timeout (30.2.4) specified by abs_time has expired. 
    Returns:
        — future_status::deferred if the shared state contains a deferred
            function.
        — future_status::ready if the shared state is ready.
        — future_status::timeout if the function is returning because the
            absolute timeout (30.2.4) specified by abs_time has expired. 
