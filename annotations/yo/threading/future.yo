Condition variables allow threads to wait until data have attained certain
values. A thread may also have to wait until a sub-thread has finished when
calling a sub-thread's tt(join) member. 

Waiting may be unwelcome: instead of just waiting our thread might also be
doing something useful. It might as well pick up the results produced by a
sub-thread at some point in the future. 

In fact, exchanging data among threads always poses some difficulties, as it
requires shared variables, and the use of locks and mutexes to prevent
data corruption. Rather than waiting and using locks it would be nice if some
asynchronous task could be started, allowing the initiating thread (or even
other threads) to pick up the result at some point in the future, whenever the
results are needed without having to worry about data locks or waiting times.
For situations like these bf(C++) provides the class tt(std::future).

Before using the class hi(future) tt(std::future) the tthi(future) header file
must be included.

Objects of the class template hi(future)tt(std::future) contain the results
produced by asynchronously executed tasks. The class tt(std::future) is a
class template. Its template type parameter specifies the type of the result
returned by the asynchronously executed task. This type may be tt(void).

On the other hand, the asynchronously executed task may itself end by throwing
an exception. In that case the tt(future) object catches the exception,
rethrowing it when its return value (i.e., the value returned by the
asynchronously executed task) is requested.

COMMENT(

By default a tt(future) object has no shared state. A tt(future) object
containing a shared state can be created by members of asynchronous providers
(such as a tt(std::promise) (cf. section ref(PROMISE)), or by the move
constructor. In these cases it shares its shared state with the original
asynchronous provider. 

END)

Some of tt(future)'s members return a value of the strongly typed
enumeration hi(future_status)tt(std::future_status). This enumeration defines
three symbolic constants: tt(future_status::ready, future_status::timeout,)
and tt(future_status::deferred). 

Error conditions may be returned by hi(future_error)tt(std::future_error)
exceptions. These error conditions are represented by the values of the
strongly typed enumeration
    hi(future_errc)tt(std::future_errc) defining the symbolic constants 
tt(future_errc::broken_promise, future_errc::future_already_retrieved, 
future_errc::promise_already_satisfied,) and tt(future_errc::no_state).

In this section the members of the class template tt(future) are
described. tt(Future) objects are commonly initialized by providing an
anonymous tt(future) object returned by factory functions. Standard available
    COMMENT(
        KLOPT DE VOLGENDE REGEL WEL? 
    )
factory functions are tt(std::async, std::promise, and std::packaged_task),
which are introduced in upcoming sections. Examples of the use of
tt(std::future) objects are provided in those sections.

The class tt(future) has the following constructors:
    itemization(
    itt(future())
        quote(The default constructor constructs an tt(future) object that
            does not refer to shared results. Its tt(valid) member returns
            tt(false).)

    itt(future(future &&tmp) noexcept)
        quote (The move constructor is available. Its tt(valid) member 
            returns what tt(tmp.valid()) would haved returned prior to the
            constructor invocation. After calling the move constructor
            tt(tmp.valid()) returns tt(false).)
    )
    The class tt(future) does not offer a copy constructor or overloaded
assignment operator. 

    COMMENT(
 (member functions of the
class tt(future) do not synchronize with themselves or with member functions
of the class tt(shared_future)).
    END)

    tt(Std::future) provides the following members:
    itemization(
    itt(future &operator=(future &&tmp))
        quote(The move assignment operator grabs the information from the
            tt(tmp) object; following this, tt(tmp.valid()) returns
            tt(false).) 

    itt(std::shared_future<ResultType> share() &&)
        quote(This member turns an r-value reference to a
            tt(future<ResultType>) into a tt(std::shared_future<ResultType>)
            (see section ref(SHAREDFUTURE)). After calling this function, the
            tt(future's valid) member returns tt(false).)

    itt(ResultType get())
        quote(This member first calls the member tt(wait) (see below), after
            which the results produced by the associated asynchronoust task
            arereturned. With tt(future<Type>) specifications the returned
            value is the moved shared value if tt(Type) supports move
            assignment, otherwise a copy is returned.  With tt(future<Type &>)
            specifications a tt(Type &) is returned, with tt(future<void>)
            specifications nothing is returned. If the shared value is an
            exception, it is thrown instead of returned. After calling this
            member the tt(future) object's tt(valid) member returns
            tt(false).)

    itt(bool valid() const)
        quote(Returns tt(true) only if tt(*this) refers to results produced by
            the associated asynchronous task.  If tt(valid) returns tt(false)
            only the tt(future's) destructor and move constructor can safely
            be called. When other members are called while tt(valid) returns
            tt(false) a hi(future_error)tt(std::future_error) exception is
            thrown (having the value hi(no_state)tt(future_errc::no_state)).)

    itt(void wait() const)
        quote(This member blocks until the results produced by
            the associated asynchronous task are available.)

COMMENT(future_status?)
    itt(future_status wait_for(chrono::duration<Rep, Period> const &rel_time) 
        const)
        quote(This member template derives the template types tt(Rep) and
            tt(Period) from the actually specified duration (cf. section
            ref(DURATION)). If the results contain a deferred function nothing
            happens. Otherwise tt(wait_for) blocks
COMMENT((30.6.8)) 
            until the results are available or until the amount of time
            specified by tt(rel_time) has expired. Possible return values are:
            itemization(
            itt(future_status::deferred) if the results contains a
                deferred function;
            itt(future_status::ready) if the results are avaiable;
            itt(future_status::timeout) if the function is returning because
                the amount of time specified by tt(rel_time) has expired. 
            ))

    itt(future_status wait_until(chrono::time_point<Clock, Duration> const
                                                        &abs_time) const)
        quote(This member template derives the template types tt(Clock) and
            tt(Duration) from the actually specified tt(abs_time) (cf. section
            ref(TIMEPOINT)). If the results contain a deferred function
            nothing happens. Otherwise tt(wait_until) blocks until the results
            are available or until the point in time specified by
            tt(abs_time) has expired. Possible return values are:
           itemization(
            itt(future_status::deferred) if the results contain a
                deferred function;
            itt(future_status::ready) if the results are available;
            itt(future_status::timeout) if the function is returning because
                the point in time specified by tt(abs_time) has expired. 
            ))
    )
    The class tt(std::future<ResultType>) declares the following friends:
        verb(
    std::promise<ResultType>
        )
    (sf. section ref(PROMISE)), and
        verb(
    template<typename Function, typename... Args>
        std::future<typename result_of<Function(Args...)>::type> 
        std::async(std::launch, Function &&fun, Args &&...args);
        )
    (cf. section ref(ASYNC)).








