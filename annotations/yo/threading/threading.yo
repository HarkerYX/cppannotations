Multi threading facilities are offered by the class tt(std::thread). 

Thread synchronization is realized using objects of the class tt(std::mutex)
and em(condition variables) are implemented by the class
tt(std::condition_variable).

Members of these classes may throw tt(system_error) objects (cf. section
ref(SYSTEMERROR)) when encountering a low-level error condition.

In order to hi(multi threading: using g++) use multi threading in bf(C++)
programs the Gnu tt(g++) compiler requires the use of the tt(-pthread)
        hi(compiler option: -pthread)hi(multi threading: -pthread)
 option. At link-time the ti(libpthread) library must be available as well. To
create  a multi-threaded program defined in a source file 
tt(multi.cc) the compiler can be called as follows:
        verb(
    g++ --std=c++11 -pthread -Wall multi.cc
        )
    When several pre-compiled objects must be linked, the tt(-lpthread)
        hi(linker option: -lpthread)hi(multi threading: -lpthread)
 linker option should also be specified.
 


COMMENT(


What if you don't want to share your data? What if you want exactly the
opposite: For each thread to have its own copy? This is the scenario addressed
by the new thread_local storage duration keyword.

Thread Local Data

The thread_local keyword can be used with any object declaration at namespace
scope at local scope, and specifies that such a variable is thread local. Each
thread thus has its own copy of that variable, and that copy exists for the
entire duration of that thread. It is essentially a per-thread static
variable, so each thread's copy of a variable declared at local scope is
initialized the first time that particular thread passes through the
declaration, and they retain their values until that thread exits:


    std::string foo(std::string const& s2)
    {
        thread_local std::string s="hello";

        s+=s2;
        return s;
    }


In this function, each thread's copy of s starts life with the contents
"hello." Every time the function is called, the supplied string is appended to
that thread's copy of s. As you can see from this example, this even works
with class types that have constructors and destructors (such as std::string),
which is an improvement over the pre-C++11 compiler extensions.

Thread-local storage isn't the only change to the concurrency support in the
core language: There's also a brand new multi-threading aware memory model,
with support for atomic operations.

The New Memory Model and Atomic Operations

Sticking to using locks and condition variables to protect your data, you
won't need to worry about the memory model. The memory model guarantees to
protect your data from race conditions-if you use locks correctly. You'll get
undefined behavior if you don't.

If you're working at a really low-level and providing high-performance library
facilities, then it's important to know the details -which are too complicated
to go into here. For now, it's enough to know that C++11 has a set of atomic
types corresponding to the built-in integer types and void pointers -and a
template std::atomic<>-which can be used to create an atomic version of a
simple user-defined type. You can look up the relevant documentation for the
details.

END)
