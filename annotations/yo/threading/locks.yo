Often locks are released at the end of some action block. To simplify locking
the template classes
        hi(unique_lock)tt(std::unique_lock) 
    and 
        hi(lock_guard)tt(std::lock_guard) 
    are provided. At construction time the tt(mutex) type to be used must be
specified. As their constructors (usually) lock the data and their destructors
unlock the data they can be defined as local variables, unlocking their data
once their scopes end.

Locks by default try to acquire the ownership of the tt(mutex) type that's
passed to them at construction time. However, that may not always be
convenient. Therefore additional constructors are defined offering additional
modes of operation. These requested modes are specified by passing 
    a emi(tag type) to those constructors that define what
should be done with the lockable object during the lock's construction. The
tag types (and tags) are:
    itemization(
    ithtq(defer_lock_t)(struct std::defer_lock_t)
       (the lock is not trying to acquire ownership of the mutex. The
        ownership may be requested later during the lock's lifetime. A
        predefined ti(defer_lock) object which may be passed as tag is also
        available;)
    ithtq(try_to_lock_t)(struct std::try_to_lock_t)
       (the lock is trying to acquire ownership of the mutex, but won't block
        if this fails. A predefined ti(try_to_lock) object which may be passed
        as tag is also available;)
    ithtq(adopt_lock_t)(struct std::adopt_lock_t)
       (the lock won't try to acquire ownership of the lock, but instead
        assumes that the calling thread has already obtained ownership. The
        lock will be released (or the lock-count will be reduced) when the
        lock is destroyed. A predefined ti(adopt_lock) which may be passed as
        tag is also available.)
    ) 

Lock types do not define copy constructors or overloaded assignment operators,
nor do they define any other member function. Essentially, they only allow
constructions. Their destructors release the ownertship of their mutex (or,
when a recursive mutex was passed to them) reduce the mutex's use count.

A ti(lock_guard) may be constructed by passing it a tt(mutex) type and an
optional tt(adopt_lock_t) object. 

Here is a simple example showing the use of a tt(lock_guard). Once
tt(safeProcess) ends tt(guard) is destroyed, thereby releasing the lock on
tt(data):
        verb(
    std::mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::lock_guard<std::mutex> guard(dataMutex);
        process(data);
    }
        )

The class template ti(unique_lock) is much more elaborate than the basic
tt(lock_guard) class template.  It does not offer a copy constructor or
overloaded assignment operator, but it em(does) offer a move constructor and
move assignment operator.

Here are its constructors and members (tt(Mutex) refers to the mutex type
that was specified for the tt(unique_lock) at construction time). E.g.,
tt(unique_lock<timed_mutex>) defines tt(Mutex) as a tt(timed_mutex) below.

Here are tt(unique_lock's) constructors:
    itemization(
    ittq(unique_lock() noexcept)
       (the default constructor is not associated with a tt(mutex) type. It
        must be assigned a tt(mutex) (e.g., using move-assignment) before it
        can do anything useful;nl())
    ittq(explicit unique_lock(Mutex& mutex))
       (initializes a tt(unique_lock) with an existing tt(Mutex) object,
        resulting in the lock object obtaining ownership of the tt(Mutex);)
    ittq(unique_lock(Mutex& mutex, defer_lock_t) noexcept)
       (initializes a tt(unique_lock) with an existing tt(Mutex) object,
        but will not try to obtain ownership of the tt(Mutex);)
    ittq(unique_lock(Mutex& mutex, try_to_lock_t) noexcept)
       (initializes a tt(unique_lock) with an existing tt(Mutex) object,
        and will try to obtain ownership of the tt(Mutex), but won't block if
        it does not succeed;)
    ittq(unique_lock(Mutex& mutex, adopt_lock_t) noexcept)
       (initializes a tt(unique_lock) with an existing tt(Mutex) object,
        assuming that the current thread has already obtained ownership of the
        tt(Mutex);)
    ittq(unique_lock(Mutex& mutex, chrono::duration<Rep, Period> const
        &relTime) noexcept)
       (this constructor is defined as a member template, using the template
        header tt(template <typename Rep, typename Period>). The template's types
        are derived from the actual tt(relTime) argument that is passed to
        the constructor, and should not explicitly be specified.  The
        constructor will try to obtain ownership of the tt(Mutex) object by
        calling tt(mutex.try_lock_for(relTime)). If tt(Mutex mutex) is
        available, this constructor could be called like this:
       verb(
unique_lock<Mutex> ulock(mutex, seconds(5));
        ))
    ittq(unique_lock(Mutex& mutex, chrono::time_point<Clock, Duration> const
        &absTime) noexcept)
       (this constructor is also defined as a member template, using the
        template header tt(template <typename Clock, typename Duration>).  The
        tt(Clock) and tt(Duration) types are derived from the actual
        tt(absTime) argument that is passed to the constructor, and should
        not explicitly be specified. The constructor will try to obtain
        ownership of the tt(Mutex) object by calling
        tt(mutex.try_lock_until(absTime)). If tt(Mutex mutex) is available,
        this constructor could be called like this:
       verb(
unique_lock<Mutex> ulock(mutex, system_clock::now() + seconds(5));
        ))
    )

Overloaded operators:
    itemization(
    ittq(explicit operator bool() const noexcept)
       (returns tt(true) if the tt(unique_lock) owns the mutex, otherwise
        tt(false); )
    ittq(unique_lock& operator=(unique_lock &&tmp) noexcept)
       (with the move-assignment operator, if the left-hand operand owns a
        lock, it will call its mutex's tt(unlock) member, whereafter tt(tmp)'s
        state is transferred to the left-hand operand)
    )

Ordinary members:
    itemization(
    ithtq(lock)(void lock())
       (blocks the current thread until ownership of the mutex that is managed
        by the tt(unique_lock) is obtained. If no mutex is currently managed,
        then a tt(system_error) exception is thrown.)
    ithtq(owns_lock)(bool owns_lock() const noexcept)
       (returns tt(true) if the tt(unique_lock) owns the mutex, otherwise
        tt(false); )
    ithtq(release)(Mutex *release() noexcept)
       (returns a pointer to the mutex object previously stored inside the
        tt(unique_lock) object, setting its own tt(Mutex *) data member to 0;)
    ithtq(swap)(void swap(unique_lock& other) noexcept)
       (swaps the states of the current tt(unique_lock) and tt(other);)
    ithtq(try_lock)(bool try_lock())
       (tries to obtain ownership of the mutex that is managed by the
        tt(unique_lock), returning tt(true) if this succeeds, and tt(false)
        otherwise. If no mutex is currently managed, then a tt(system_error)
        exception is thrown.)
    ithtq(try_lock_for)(bool try_lock_for(chrono::duration<Rep, Period> const
        &relTime)) 
       (this member is defined as a member template, using the template header
        tt(template <typename Rep, typename Period>). The template's types are
        derived from the actual tt(relTime) argument that is passed to this
        member, and should not explicitly be specified.  This member function
        will try to obtain ownership of the tt(Mutex) object managed by the
        tt(unique_lock) object by calling the mutex's
        tt(try_lock_for(relTime)) member.)
    ithtq(try_lock_until)(bool try_lock_until(chrono::time_point<Clock,
        Duration> const &absTime))
       (this member is also defined as a member template, using the template
        header tt(template <typename Clock, typename Duration>).  The
        tt(Clock) and tt(Duration) types are derived from the actual
        tt(absTime) argument that is passed to th is member function, and
        should not explicitly be specified. This member function will try to
        obtain ownership of the tt(Mutex) object managed by the
        tt(unique_lock) object by calling the mutex's
        tt(mutex.try_lock_until(absTime)) member.)
    ithtq(unlock)(void unlock())
       (releases ownership of the mutex (or reduces the mutex's lock count). A
        tt(system_error) exception is thrown if the tt(unique_lock) does not
        own the mutex.)
    ithtq(mutex)(Mutex *mutex() const noexcept)
       (returns a pointer to the mutex object stored inside the
        tt(unique_lock) (a tt(nullptr) is returned if no mutex object is
        currently stored inside the tt(unique_lock) object.))
    )

Here is a simple example showing a tt(unique_lock) being used trying to obtain
ownership of a tt(timed_mutex):
        verb(
    std::timed_mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::unique_lock<std::timed_mutex>
            guard(dataMutex, std::chrono::milliseconds(3));
        if (guard)
            process(data);
    }
        )
    In the above example tt(guard) tries to obtain the lock during three
milliseconds. If tt(guard)'s tt(operator bool) returns tt(true) the lock was
obtained and tt(data) can be processed safely.
