As we've seen in section ref(OVERLOADBINARY) binary operators expecting
tt(const &) arguments can be implemented using a member implementing the
operation, only offering the basic exception guarantee.
This latter function can in turn be implemented using the binary
assignment member. The following examples illustrated this approach for a
fictitious class tt(Binary):
        verbinclude(-a ../overloading/examples/binary4.h)

Eventually, the implementation of binary operators depends on the availability
of the member implementing the basic binary operation, modifying the object
calling that member (i.e., tt(void Binary::add(Binary const &)) in the
example).

Since template functions are not instantiated before they are actually used we
can call non-existing functions from template functions that are never
instantiated. If such a template function is If such a template function is
never instantiated, nothing happens; if it is (accidentally) instantiated,
then the compiler generates an error message, complaining about the missing
function.

This allows us to implement all binary operators, movable and non-movable, as
templates. In the following subsections we develop the class template
tt(Binops), offering binary operators (in this section we develop the addition
and the stream-insertion operator, but the example can directly be generalized
to other binary operators and to the stream-extraction operator). 

===============================================================

Classes also frequently define overloaded insertion and extraction
operators. Since there are no associated `compound insertion operators' the
approach discussed so far cannot be used when overloading these
operators. Instead the use of standardized member function signatures is
advocated: tt(void insert(std::ostream &out) const) to insert an object into
an tt(ostream) and tt(void extract(std::istream &in) const) to extract an
object from an tt(istream). As these  functions are only called by,
respectively, the insertion and extraction operators, they can be declared in
the tt(Derived) class's private interface. Instead of declaring the insertion
and extraction operators friends of the class tt(Derived) a simpler tt(friend
Binops<Derived>) can be declared. Doing so, tt(Binops<Derived>) can provide
private, inline tt(iWrap) and tt(eWrap) members, merely calling, respectively, 
tt(Derived's insert) and tt(extract) members. E.g.,
        verb(
    template <typename Derived>
    void Base<Derived>::iWrap(std::ostream &out) const
    {
        static_cast<Derived const &>(*this).insert(out);
    }
        )
    In addition, tt(Base) can declare the insertion and extraction operators
as its friends, allowing these operators to call, respectively, tt(iWrap) and
tt(eWrap). The overloaded insertion operator then looks like this:
        verb(
    template <typename Derived>
    std::ostream &operator<<(std::ostream &out, Base<Derived> const &obj)
    {
        obj.iWrap(out);
        return out;
    }
        )
    
A complete implementation of a class tt(Derived) supporting addition and
insertion  operators is provided in the file 
tt(annotations/yo/concrete/examples/binopclasses.cc) in the annotations()'
source archive.
