In the previous section we saw that binary operators (like tt(operator+)) can
be implemented very efficiently, but still require at least move constructors.

An expression like
        verb(
    Binary{} + varB + varC + varD
        )
  therefore returns a move constructed object representing tt(Binary{} +
varB), then another move constructed object receiving the first return value
and tt(varC), and finally yet another move constructed object receiving the
second returned object and tt(varD) as its arguments.

Now consider the situation where we have a function defining a tt(Binary &&)
parameter, and a second tt(Binary const &) parameter. Inside that function
these values need to be added, and their sum is then passed as argument to two
other functions. We em(could) do this:
        verb(
    void fun1(Binary &&lhs, Binary const &rhs)
    {
        lhs += rhs;
        fun2(lhs);
        fun3(lhs);
    }
        )
    But realize that when using tt(operator+=) we first construct a copy of
the current object, so a temporary object is available to perform the addition
on, and then swap the temporary object with the current object to commit the
results. But wait! Our lhs operand already em(is) a temporary object. So why
create another?

    In this example there's indeed no need for yet another temporary
object. But different from the binary operators compound assignment operators
don't have a explicitly defined lhs operand. In situations like these we
nevertheless can inform the compiler that a member (not just compound
assignment operators) should only be used when the objects calling those
members is an rvalue reference, or an lvalue reference to either a modifiable
or non-modifiable object. For this we use 
    em(reference bindings)hi(reference binding) a.k.a.  
    em(reference qualifiers)hi(reference qualifier). 

    Reference bindings consist of a reference token (tt(&)), optionally
preceded by tt(const), or an rvalue reference token (tt(&&)). Such reference
qualifiers are is affixed immediately to the function's head (this applies to
the declaration and the implementation alike). Functions provided with rvalue
reference bindings are used when called by anonymous temporary objects,
whereas functions provided with lvalue reference bindings are used when called
by other types of objects.

    Reference qualifiers allow us to fine-tune our implementations of
tt(operator+=). If we know that the object calling the compound assignment
operator is itself a temporary, then there's no need for a separate temporary
object. The operator may directly perform its operation and then return. Here
is the implementation of tt(operator+=) tailored to being used by temporary
objects:
        verb(
    Binary &&Binary::operator+=(Binary const &rhs) &&
    {
        add(rhs);                   // directly add rhs to *this, 
        return std::move(*this);    // return *this as rvalue ref.
    }
        )    
    This implementation is about as fast as it gets. So, for that
operator we use (note the reference qualifier):
        verb(
    Binary &Binary::operator+=(Binary const &other) &
    {
        Binary tmp(*this);
        tmp.add(other);     // this might throw
        swap(tmp);
        return *this;
    }
        )
    With this implementation adding a tt(Binary) object to another boils down
to
        verb(
    operator+=    (&)       = b1 += b2 
    Copy constructor        = tmp(b1) 
        adding              = tmp.add(b2)
    swap                    = tmp <-> *this
        )
    Although een interesting alternative implementation exists, it's somewhat
less efficient than the above. The alternative implementation looks like
this:
        verb(
    // not advised:
    Binary &Binary::operator+=(Binary const &other) &
    {
        return *this = Binary{*this} += rhs;
    }
        )
    When this implementation is used we observe:
        verb(
    operator+=    (&)       = b1 += b2 
    Copy constructor        = tmp(b1) 
    operator+=    (&&)      = tmp += b2
        adding              = tmp.add(b2)
    move assign             = *this = tmp
        )

    Notice that the implementations of tt(operator+) and tt(operator+=) are
independent of the actual definition of the class tt(Binary). Adding standard
binary operators to a class (i.e., operators operating on arguments of their
own class types) can therefore easily be realized.

    Summarizing:
    itemization(
    it() Reference qualifiers are used to inform the compiler about which
overloaded version of a member should be called for which type of object;
    it() Binary operators can capitalize on these functions to minimize the
number of copy constructions that must be performed;
    )

    








