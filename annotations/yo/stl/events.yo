In this section em(condition variables) are introduced, allowing programs to
synchronize threads on the em(states) of data, rather than on the em(access)
to data, which is realized using  mutexes.

Before using condition variables the tthi(condition_variable) header file must
have been included.

To start our discussion, we consider a classic producer-consumer scenario: the
producer generates items to be consumed by a consumer. The producer can only
produce a certain number of items before its storage capacity has filled up
and the client cannot consume more items than the producer has produced.

At some point the producer has to wait until the client has consumed enough,
thus creating space in the producer's storage. Similarly, the consumer cannot
start consuming until the producer has at least produced some items.

Mutexes (data locking) don't result in elegant solutions of producer-consumer
types of problems, as using mutexes requires repeated locking and polling the
amount of available items/storage. This isn't a very attractive option as it
wastes resources. Polling forces threads to wait until they own the mutex,
even though continuation might already be possible. The polling interval could
be reduced, but that too isn't an attractive option, as it results in
needlessly increasing the overhead associated with handling the associated
mutexes.

On the other hand, condition variables allow you to avoid polling by
synchronizing threads using the em(states) (e.g., em(values)) of data.

As the the states of the data may be modified by multiple threads, threads
still have to use mutexes, but merely to control access to the data. However,
condition variables allow threads to release ownership of the mutex until a
certain state has been reached, until a preset amount of time has been passed,
or until a preset point in time has been reached.

The prototypical setup of these kinds of programs look like this:
    itemization(
    it() consumer thread(s) act like this:
        verb(
    obtain ownership of the used mutex
    while the required condition is false:
        release the ownership and wait until being notified
    continue processing now that the condition is true
    release ownership of the mutex
        )
    it() producer thread(s) act like this:
        verb(
    obtain ownership of the used mutex 
    while the condition is false:
        work towards changing the condition to true
    signal other waiting threads that the condition is now true
    release ownership of the mutex
        )
    )

Condition variables come in two flavors: objects of the class 
    hi(condition_variable)tt(std::condition_variable) are used in combination
with objects of type tt(unique_lock<mutex>). This combination allows
optimizations resulting in an increased efficiency compared to the efficiency
that can be obtained with objects of the class
    hi(condition_variable_any)tt(stdLLcondition_variable_any) that can be used
with any (e.g., user-supplied) lock types.

The condition variable classes offer members like tt(wait, wait_for,
wait_until, notify_one) and tt(notify_all) that may concurrently be called.
The notify members are always atomically executed. Execution of the
tt(wait) members consists of three atomic parts:
    itemization(
    it() the mutex's release, and subsequent entry into the waiting state;
    it() unblocking the wait state;
    it() reacquisition of the lock.
    )
    Therefore, returning from tt(wait)-members the thread calling wait owns
the lock.

Programs using condition variables cannot make any assumption about the order
in which any of the tt(notify_one, notify_all, wait, wait_for), and
tt(wait_until) members are executed.

In addition to the condition variable classes the following free function and
tt(enum) type are provided:
    itemization(
    itht(notify_all_at_thread_exit)(void 
            std::notify_all_at_thread_exit+OPENPARcondition_variable &cond,)
            linebreak()tt(unique_lock<mutex> lockObject+CLOSEPAR:)
       quote(once the current thread has ended, all other threads waiting on
        tt(cond) will be notified. It is good practice to exit the thread as
        soon as possible after calling linebreak()
        tt(notify_all_at_thread_exit).

       Waiting threads must verify that the thread they were waiting for has
        indeed ended. This is usually implemented by obtaining the lock on
        tt(lockObject), after which these threads verify that the condition
        they were waiting for is true, and that the lock was not released and
        reacquired before tt(notify_all_at_thread_exit) was called.)
    it() hi(cv_status)
        quote(
            The tt(cv_status) enum is used by several member functions of the
condition variable classes covered below:
        verb(
    namespace std
    {
        enum class cv_status 
        { 
            no_timeout, 
            timeout 
        };
    }
        )
            )
    )
