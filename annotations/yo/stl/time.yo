Traditionally, bf(sleep)(3) or bf(select)(2) are the tools used to postpone a
program for a specified amount of time. When developing multi threaded
programs situations are frequently encountered where one thread's actions are
temporarily suspended. E.g., a program configuring a network interface may
want to show that it's busy by displaying a sequence of dots, one dot per
second, until the network interface has been configured. The thread displaying
de dots waits for a second before displaying the next dot. Once the network
interface has been configured the the other tread should be notified that it
should stop, requiring facilities to interrupt the waiting process.

The STL offers dedicated classes which work well in combination with threads,
the topic of the next section, but which can also used in many other
situations. 

--------------------
 In the annotations() these classes are covered for as much as
required in combination with multi-threading. The user is referred to the
C++11 standard for additional details about tt(ratio, duration), and
tt(time_point). 

Before using either tt(duration) or tt(time_point) the
tthi(chrono) header file must have been included, where the latter header file
includes the former.

and a specific point in time is defined using the class template
    tt(time_point).

Once a tt(ratio) type has been defined (e.g.,
tt(typedef ratio<1, 1000> milli)) or becomes available (e.g., as
tt(seconds::period), see below), then the value of the template's first
argument (e.g., 1) can be retrieved as ti(num) (e.g.,
tt(seconds::period::num)), while the value of the template's second argument
(e.g., 1000) can be retrieved as ti(den) (e.g., tt(seconds::period::den)).

