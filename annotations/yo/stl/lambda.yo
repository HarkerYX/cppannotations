The C++11 standard adds hi(lambda expression) em(lambda expressions) to the
language. As we'll see in chapter ref(19) em(generic algorithms) often accept
arguments that can either be function objects or plain functions . Examples
are the tt(sort) (cf. section ref(SORT)) and tt(find_if) (cf. section
ref(FINDIF)) generic algorithms. As a i(rule of thumb): when a called function
must remember its state a function object is appropriate, otherwise a plain
function can be used.

Frequently the function or function object is not readily available, and it
must be defined in or near the location where it is used.  This is commonly
realized by defining a class or function in the anonymous namespace (say:
class or function A), passing an A to the code needing A. If that code is
itself a member function of the class B, then A's implementation might benefit
from having access to the members of class B.

Often this scheme results in a significant amount of code (defining the
class), or it results in complex code (to make available software elements
that aren't automatically accessible to A's code). It may also result in code
that is irrelevant at the current level of specification. Nested classes don't
solve these problems either. Moreover, nested classes can't be used in
templates.

Lamba expressions solve these problems.  A i(lambda expression) defines an
    i(anonymous function object)hi(function object: anonymous), also called a
    emi(closure object). When a lambda expression is evaluated it results in a
temporary object (the closure object). The type of a closure object is called
its emi(closure type). 

Lambda expressions may be used inside blocks, classes or namespaces (i.e.,
pretty much anywhere you like). Their implied closure type is defined in the
smallest block, class or namespace scope which contains the lamba
expression. The closure object's visibility starts at its point of definition
and ends where its closure type ends.

The closure type defines a (tt(const)) public inline function call
operator. Here is an example of a lambda expression:
    hi(lambda-introducer)
    hi(lambda-declarator)
        verb(
    []                      // the `lambda-introducer'
    (int x, int y)          // the `lambda-declarator'
    {                       // a normal compound-statement
        return x * y;
    }
        )
    The function call operator of the closure object created by this lambda
expression expects two tt(int) arguments and returns their product. It is an
inline tt(const) member of the closure type. To drop the tt(const) attribute,
the lamba expression should specify tt(mutable), as follows:
        verb(
    [](int x, int y) mutable
    ...
        )
    The lambda-declarator may be omitted, if no parameters are defined. The
parameters in a lamba declarator may not be given default arguments.


A closure object as defined by the above lamda expression could be used e.g.,
in combination with the tt(accumulate) (cf. section ref(ACCUMULATE)) generic
algorithm to compute the product of a series of tt(int) values stored in a
vector:
        verb(
    cout << accumulate(vi.begin(), vi.end(), 1,
                [](int x, int y) { return x * y; });
        )
    The above lambda function uses the implicit return
        hi(return type: implicit)
    type tt(decltype(x * y)). An implicit return type can be used if the
lambda expression does not contain a tt(return) statement (i.e., a void
lambda expression), if it contains a single tt(return) statement, or if it
contains multiple tt(return) statements returning values of identical types
(e.g., all tt(int) values). 

    If there are multiple tt(return) statements returning values of different
types then the lambda expression's return type must specified be explicitly
using a
        hi(return type: late-specified)i(late-specified return type),
(cf. section ref(AUTO)):
        verb(
    [](int x, int y) -> int
    {
        if (y < 0)
            return x / static_cast<double>(y);

        return z + x;
    }
        )

    Variables that are visible at the location of a lambda expression can be
accessed by the lambda expression. How these variables are accessed depends on
the contents of the lambda-introducer (the area between the square brackets,
called the the emi(lambda-capture)). The lambda-capture allows passing a
    i(local context) to lambda expressions. 

    Visible global and static variables as well as local variables defined in
the lambda expression's compound statement itself can directly be accessed
and, if applicable, modified. Example:
        verb(
    int global;
    
    void fun()
    {
        []()  // [] may contain any specification
        { 
            int localVariable = 0;
            localVariable = ++global; 
        };
    }
        )

    If the lambda expression is defined within a (non-static) class member
function then an initial tt(&) or tt(=) character in the lambda-capture
enables tt(this), allowing the lambda expression access to all class members
(data and functions).  The class's data members can be modified.

    If the lambda expression is defined inside a function then that function's
local variables that are visible at the point of the lambda expression's
definition can be accessed by the lambda expression.

    An initial tt(&) character in the lambda-capture accesses these local
variables by reference. These variables can be modified from within the lambda
expression.

    An initial tt(=) character in the lambda-capture creates a local copy of
the referred-to local variables. Furthermore, in this case the values of these
local copies can only be changed by the lambda expression if the lambda
expression is defined using the tt(mutable) keyword. E.g.,
        verb(
    struct Class
    {
        void fun()
        {
            int var = 0;
            [=]() mutable
            {
                ++var;  // modifies the local
            }           // copy, not fun's var
        }
    }
        )

    Fine-tuning is also possible. With an initial tt(=), comma-separated
tt(&var) specifications indicate that the mentioned local variables should be
processed by reference, rather than as copies; with an initial tt(&), comma
separated tt(var) specifications indicate that local copies should be used of 
the mentioned local variables. Again, these copies have immutable values
unless the lambda expression is provided with the tt(mutable) keyword. 

Here is an example, using the tt(for_each) (cf. section ref(FOREACH)) generic
algorithm: 
        verb(
    void showSum(vector<int> const &vi)
    {
        int total = 0;
        for_each(
            vi.begin(), vi.end(),
            [&](int x)
            {
                total += x;
            }
        );
        std::cout << total << '\n';
    }
        )
    The variable tt(int total) is passed to the lambda expression by reference
and is directly accessed by the function. Its parameter list merely defines an
tt(int x), which is initialized in sequence by each of the values stored in
tt(vi). Once the generic algorithm has completed tt(showSum)'s variable
tt(total) has received a value that is equal to the sum of all the vector's
values. It has outlived the lambda expression and its value is displayed.

Although generic algorithms are extremely useful, they may not always be
available for the task at hand. Moreover, an algorithm like tt(for_each) looks
a bit unwieldy, now that the language offers range-based for-loops. So let's
try this, instead of the above implementation:
        verb(
    void showSum(vector<int> const &vi)
    {
        int total = 0;
        for (auto el: vi)
            [&](int x)
            {
                total += x;
            };

        std::cout << total << '\n';
    }
        )
    But when tt(showSum) is now called, its tt(cout) statement consistently
reports 0. What's happening here?

    When a generic algorithm is given a lambda function, its implementation
instantiates a reference to a function, and that function is thereupon called
from within the generic algorithm. However, in the above example the
range-based for-loop's nested statement merely represents the declaration of a
lamba function: nothing is actually called, and hence tt(total) remains equal
to 0. So, to make the above example work we not only must em(define) the
lambda expression, but we must also em(call) the lambda function. One way of
doing that is by giving the lambda function a em(name), and then call the
lamba function by its given name:
        verb(
    void showSum(vector<int> const &vi)
    {
        int total = 0;
        for (auto el: vi)
        {
            auto lambda = [&](int x)
                            {
                                total += x;
                            };

            lambda(el);
        }
        std::cout << total << '\n';
    }
        )
    
In fact, there is no need to give the lambda function a name: the tt(auto
lambda) declaration merely represents the lambda function, which could also
directly be called, as an extension of its definition. The syntax may look a
bit weird, but there's nothing wrong with it, and it allows us to drop the
compound statment, required in the last example, completely. Here goes:
        verb(
    void showSum(vector<int> const &vi)
    {
        int total = 0;
        for (auto el: vi)
            [&](int x)
            {
                total += x;
            }(el);          // immediately append the 
                            // argument list to the lambda
                            // function's definition
        std::cout << total << '\n';
    }
        )




Another fine-tuning uses tt(this) in the lambda-capture: it also allows the
lambda-expression to access the surrounding class members.  Example:
        verb(
    class Data
    {
        std::vector<std::string> d_names;
        public:
            void show() const
            {
                int count = 0;
                std::for_each(d_names.begin(), d_names.end(),
                    [this, &count](std::string const &name)
                    {
                        std::cout << ++count << ' ' <<
                            capitalized(name) << '\n';
                    }
                );
            }
        private:
            std::string capitalized(std::string name);
    };
        )

    Lambda expressions may also be assigned to variables. An example of such
an assignment (using tt(auto) to define the variable's type) is:
        verb(
    auto sqr = [](int x)
               {
                   return x * x;
               };
        )
    The lifetime of such lambda expressions is equal to the lifetime of the
variable receiving the lambda expression as its value. Named lambda functions
nicely fit in the niche of local functions: when a function needs to perform
some computations that are at a conceptually lower level than the function's
task itself, then it's attractive to encapsulate these computations in a
separate support function, and call the support function where needed.  A
support function can be defined in an anonymous namespace, but that quickly
becomes awkward when the requiring function is a class member, and the support
function needs access to the class's members as well. In that case a named
lambda expression can be used: it can be defined within the requiring
function, and may be given full access to the surrounding class. The name to
which the lambda expression is assigned becomes the name of a function which
can be called from the surrounding function. Here is an example, converting a
numeric IP address to a dotted decimal string, which can also be accessed
directly from an tt(Dotted) object (all implementations in-class to conserve
space):
        verb(
    class Dotted
    {
        std::string d_dotted;
        
        public:
            std::string const &dotted() const
            {
                return d_dotted;
            }
            std::string const &dotted(size_t ip)
            {
                auto octet = 
                    [](size_t idx, size_t numeric)
                    {
                        return to_string(numeric >> idx * 8 & 0xff);
                    };

                d_dotted = 
                        octet(3, ip) + '.' + octet(2, ip) + '.' +
                        octet(1, ip) + '.' + octet(0, ip);

                return d_dotted;
            }
    };
        )

Now that lambda expressions have been covered let's see how they can be used
to avoid spurious returns from tt(condition_variable's wait) calls
(cf. section ref(CONDEX)). According to the C++11 standard, condition
variables may spuriously return from tt(wait) calls. Therefore it is necessary
to check that the data are actually available once tt(wait) continues. 

The class tt(condition_variable) allows us to do that by offering tt(wait)
members expecting a lock em(and) a predicate. The predicate checks the data's
state, and returns tt(true) if the data's state allows the data's
processing. Here is an alternative implementation of the tt(down) member shown
in section ref(CONDEX), checking for the data's actual availability:
        verb(
    void down()
    {
        unique_lock<mutex> lock(sem_mutex);
        condition.wait(lock, 
            [&]()
            {
                return semaphore != 0
            }
        );
        --semaphore;
    }
        )
    The lambda expression ensures that tt(wait) only returns once
tt(semaphore) has been incremented.
    

