em(Binders) hi(binder) are function adaptors converting
 hi(binary function object) binary function objects to
 hi(unary function object) unary function objects. They do so by em(binding)
one parameter of a binary function object to a constant value. For example, if
the first parameter of the tt(minus<int>) function object is bound to 100,
then the resulting value is always equal to 100 minus the value of the
function object's second argument.

Originally two binder adapters (ti(bind1st) and ti(bind2nd)) binding,
respectively, the first and the second argument of a binary function were
defined. However, in the upcoming i(C++17) standard tt(bind1st) and
tt(bind2nd) are likely to be removed, as they are superseded by the more
general tt(bind) binder. tt(Bind) itself is likely to become a deprecated
function, as it can easily be replaced by em(lambda functions) (cf. section
ref(LAMBDA)).

As tt(bind1st) and tt(bind2nd) are still available, a short example showing
their use (concentrating on tt(bind2nd) should suffice. A more elaborate
example, using tt(bind) is shown next. Existing code should be modified so
that either tt(bind) or a lambda function is used.

Here is an example showing how to use tt(bind2nd) to count the number of
strings that are equal to a string (tt(target)) in a vector of strings
(tt(vs)): 
        verb(
    count_if(vs.begin(), vs.end(), bind2nd<equal_to<string>(), target);
        )
    In this example the function object tt(equal_to) is instantiated for
strings, receiving tt(target) as its second argument, and each of the strings
in tt(vs) are passed in sequence to its first argument. In this particular
example, where equality is being determined, tt(bind1st) could also have been
used. 



    Although binders are defined as templates, it is illustrative to have a
look at their implementations, assuming they were ordinary classes. Here is
such a pseudo-implementation of the tt(bind2nd) function adaptor:
        verb(
    class bind2nd
    {
        FunctionObject d_object;
        Operand const &d_operand;
        public:
            bind2nd(FunctionObject const &object, Operand const &operand);
            ReturnType operator()(Operand const &lvalue);
    };
    inline bind2nd::bind2nd(FunctionObject const &object,
                            Operand const &operand)
    :
        d_object(object),
        d_operand(operand)
    {}
    inline ReturnType bind2nd::operator()(Operand const &lvalue)
    {
        return d_object(lvalue, d_operand);
    }
        )
    The binder's tt(operator()) merely calls the function object's
tt(operator()), providing it with two arguments. It uses its parameter as the
(latter) tt(operator())'s first argument and it uses tt(d_operand) as
tt(operator())'s second argument.  The adaptor's members are typically very
small so they are usually implemented inline.

    The above application of the tt(bind2nd) adaptor has another important
characteristic. Its return type is identical to the return type of the
function object that it receives as its first argument, which is
tt(bool). Functions hi(predicate function) returning tt(bool) values are also
called em(predicate functions). In the above application the tt(bind2nd)
adaptor therefore becomes a predicate function itself.

