The i(C++11) standard adds handling of i(regular expressions) to the
language. Before using regular expressions as offered by the C++ standard the
header file tthi(regex) must be included.

Regular expressions were already available in bf(C++) via its bf(C) heritage
as bf(C) has always offered functions like ti(regcomp) and
ti(regexec). bf(C++) itself did not provide facilities for handling regular
expressions. Programmers had to use the basic tt(std::string) matching
procedures (like tt(find_first_of)), thus avoiding regular expressions, or
they had to use the existing bf(C) functions
(which do not encapsulate the (manipulation of the) required data structures),
or they could handle regular expressions using regular expression classes made
available by third-party libraries (like the ti(Pattern) class of the
    url(Bobcat library)(http://bobcat.sourceforge.net)).
    hi(Bobcat library)hi(http://bobcat.sourceforge.net)

Regular expressions are extensively documented elsewhere (e.g., bf(regex)(7),
i(Friedl, J.E.F)
    url(Mastering Regular Expressions)(http://oreilly.com/catalog/), O'Reilly)
    and the reader is referred to these sources for a refresher on the topic
of regular expressions. In essence, regular expressions define a small
meta-language with which textual units (like `numbers', `identifiers', etc.)
can be recognized. They are extensively used in the context of em(lexical
scanners) (cf. section ref(Flexcpp)) when defining the sequence of input
characters associated with em(tokens). But they are intensively used in other
situations as well. E.g., programs like bf(sed)(1) and bf(grep)(1) use regular
expressions to find pieces of text in files having certain characteristics;
and a programs like bf(perl)(1) adds some `sugar' to the regular expression
language, simplifying the construction of regular expressions. However, though
extremely useful, its also well known that regular expressions tend to be very
hard to read. Some even call the regular expression language a em(write-only
language): while specifying a regular expression it's often clear why it's
written in a particular way. But the opposite, understanding what a regular
expression is supposed to represent if you lack the proper context, can be
extremely difficult. That's why, from the onset and as a emi(rule of thumb),
it is stressed that an appropriate comment should be provided, with em(each)
regular expression, as to what it is for and what it is supposed to match.

In the upcoming sections first a short overview of the regular expression
language is provided, which is then followed by the facilities bf(C++) is
currently offering for using regular expressions. These facilities mainly
consist of classes helping you to specify regular expression, matching them to
text, and determining which parts of the text (if any) match (parts of) the
text being analyzed.

