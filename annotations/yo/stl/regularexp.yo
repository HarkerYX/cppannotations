The i(C++11) standard adds handling of i(regular expressions) to the
language. Before using regular expressions as offered by the C++ standard the
header file tthi(regex) must be included.

Regular expressions were already available in bf(C++) via its bf(C) heritage
as bf(C) has always offered functions like ti(regcomp) and
ti(regexec). bf(C++) itself did not provide facilities for handling regular
expressions. Programmers had to use the basic tt(std::string) matching
procedures (like tt(find_first_of)), thus avoiding regular expressions, or
they had to use the existing bf(C) functions (which do not encapsulate
(manipulating) the required data structures), or regular expressions where
available through regular expression classes made available by third-party
libraries (like the ti(Pattern) class of the
    url(Bobcat)(http://bobcat.sourceforge.net)) library.
    hi(Bobcat library)hi(http://bobcat.sourceforge.net)

Regular expressions are extensively documented elsewhere (e.g., bf(regex)(7),
i(Friedl, J.E.F)
  url(Mastering Regular Expressions)(http://oreilly.com/catalog/), O'Reilly).
    The reader is referred to these sources for a refresher on the topic of
regular expressions. In essence, regular expressions define a small
meta-language recognizing textual units (like `numbers', `identifiers', etc.).
They are extensively used in the context of em(lexical scanners) (cf. section
ref(Flexcpp)) when defining the sequence of input characters associated with
em(tokens). But they are also intensively used in other situations.  Programs
like bf(sed)(1) and bf(grep)(1) use regular expressions to find pieces of text
in files having certain characteristics, and a program like bf(perl)(1) adds
some `sugar' to the regular expression language, simplifying the construction
of regular expressions. However, though extremely useful, it is also well
known that regular expressions tend to be very hard to read. Some even call
the regular expression language a em(write-only language): while specifying a
regular expression it's often clear why it's written in a particular way. But
the opposite, understanding what a regular expression is supposed to represent
if you lack the proper context, can be extremely difficult. That's why, from
the onset and as a emi(rule of thumb), it is stressed that an appropriate
comment should be provided, with em(each) regular expression, as to what it is
supposed to match.

In the upcoming sections first a short overview of the regular expression
language is provided, which is then followed by the facilities bf(C++) is
currently offering for using regular expressions. These facilities mainly
consist of classes helping you to specify regular expression, matching them to
text, and determining which parts of the text (if any) match (parts of) the
text being analyzed.

