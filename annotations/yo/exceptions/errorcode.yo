Error code objects are used by tt(error_category) or tt(system_error)
objects. E.g., some constructors of the class tt(system_error) accept objects
of the class hi(error_code). The main purpose of tt(std:error_code) objects is
to encapsulate platform dependent em(error code values), which may be
determined by the operating system or comparable low-level functions (like
bf(chmod)(2)), and assigned to, e.g., tt(errno). In addition, an
tt(error_category) specifying the general category of the encountered error
(see the next

The class tt(error_code) provides the following constructors, members, and
free functions:

bf(Constructors):
    itemization(
    ittq(error_code() noexcept)
       (the default constructor initializes the error code with an error
        em(value) 0 and an error em(category) set to tt(&system_category());)

    ittq(error_code(int ec, error_category const &cat) noexcept)
       (this constructor initializes the error code with error value tt(ec)
        (e.g., tt(errno), set by a failing function), and an error
         em(category) (e.g., tt(&system_category()) or
         tt(generic_category()));)

    ittq(error_code(ErrorCodeEnum e) noexcept)
       (this is a member template (cf. section ref(MEMTEMP)), defining
        tt(template <class ErrorCodeEnum>). It initializes the object with the
        return value of tt(make_error_code(e)).)
    )

    The copy and move constructors are available.

bf(Members):
    itemization(
    ittq(void assign(int val, error_category const &cat))
       (assigns new values to the current object's em(value) and
        em(category) data members;)
    ittq(error_category const &category() const noexcept)
       (returns a reference to the object's error category;)
    ittq(void clear() noexcept)
       (after calling this member em(value) is set to 0 and the object's error
        em(category) set to tt(&system_category());)
    ittq(error_condition default_error_condition() const noexcept)
       (returns tt(category().default_error_condition(value()));)
    ittq(string message() const)
       (returns tt(category().message(value()));)
    ittq(errorcode& operator=(ErrorCodeEnum e) noexcept)
       (a member template defining
        tt(template <class ErrorCodeEnum>). It assigns the return value of 
        tt(make_error_code(e)) to the current object;)
    ittq(explicit operator bool() const noexcept)
       (returns tt(value() != 0);)
    ittq(int value() const noexcept)
       (returns the object's error value.)
    )

bf(Free functions):
    itemization(
    ittq(error_code make_error_code(errc e) noexcept)
       (returns tt(error_code(static_cast<int>(e), generic_category()))
        (tt(errc: see below));)

    ittq(bool operator<(error_code const &lhs, error_code const &rhs)
        noexcept)
       (returns 
    verb(
lhs.category() < rhs.category() 
|| 
lhs.category() == rhs.category() && lhs.value() < rhs.value();
        ))

    ittq(std::ostream &operator<<(std::ostream & os, error_code const &ec))
       (inserts the following text into tt(os):
    verb(
os << ec.category().name() << ':' << ec.value().
        ))
    )


The ti(enum class errc)hi(errc) defines symbols that have identical values as
the traditional error code values as offered by bf(C) macros but whose values
describe the error conditions in a less cryptic way , e.g.,
        verb(
    enum class errc 
    {
        address_family_not_supported, // EAFNOSUPPORT
        address_in_use,               // EADDRINUSE
        address_not_available,        // EADDRNOTAVAIL
        already_connected,            // EISCONN
        argument_list_too_long,       // E2BIG
        argument_out_of_domain,       // EDOM
        bad_address,                  // EFAULT
        ...
    };
        )

Several other strongly typed enums also exist. E.g., the tt(enum class
future_errc) (cf. section ref(FUTURE)) defines error symbols that are used in
the context of multi-threading. 









