The keyword ti(auto) can be used to simplify type definitions of variables and
return types of functions if  the compiler is able to determine the proper
types of such variables or functions.

Using tt(auto) as a storage class specifier is no longer supported by bf(C++):
a variable definition like tt(auto int var) results in a compilation error.

The keyword tt(auto) is frequently used in situations where it is very hard to
determine the variable's type. These situations are encountered, e.g., in the
context of em(templates) (cf. chapters ref(STL) until ref(ADVANCEDTEMPL).

At this point in the Annotations only simple examples can be given.  Refer to
section ref(AUTODECL) for additional information about tt(auto) (and the
related tt(decltype) function).

When defining and initializing a variable tt(int variable = 5) the type of the
initializing expression is well known: it's an tt(int), and unless the
programmer's intentions are different this could be used to define
tt(variable)'s type (a somewhat contrived example as in this case it
reduces rather than improves the clarity of the code):
        verb(
    auto variable = 5;
        )

    However, here are some examples where tt(auto) can profitably be used.  In
chapter ref(String) the emi(iterator) concept is introduced (see also chapters
ref(CONTAINERS) and ref(STL)). Iterators sometimes have long type definitions,
like
        verb(
    std::vector<std::string>::const_reverse_iterator
        )
    Functions may return types like this. Since the compiler knows the
types returned by functions we may exploit this knowledge by using
tt(auto). Assume that a function tt(begin()) is declared like this:
        verb(
    std::vector<std::string>::const_reverse_iterator begin();
        )
    Rather than writing the verbose variable definition (at tt(//
1), below) a much shorter definition (at tt(// 2)) can be used:
        verb(
    std::vector<std::string>::const_reverse_iterator iter = begin();    // 1
    auto iter = begin();                                                // 2
        )
    It's easy to define additional variables of this type. When initializing
those variables using tt(iter) the tt(auto) keyword can again be used:
        verb(
    auto start = iter;
        )
    A definition using a mere tt(auto) results in a plain, non-reference type
(or a pointer type if the initializing expression is a pointer expression). If
a reference type is requested, ti(auto &) or tt(auto &&) can be
used. Likewise, tt(const) and/or pointer specifications can be used. Examples:
        verb(
    int value;
    auto another = value;   // value is int, so 'int another' is defined

    string const &text();
    auto str = text();      // text's plain type is string, so 
                            // string str, NOT string const str
                            // is defined
    str += "...";           // OK

    int *ip = &value;
    auto ip2 = ip;          // int *ip2, pointing at value, is defined.
        )
