The keyword ti(auto) can be used to simplify type definitions of variables and
return types of functions if  the compiler is able to determine the proper
types of such variables or functions.

Using tt(auto) as a storage class specifier is no longer supported by bf(C++):
a variable definition like tt(auto int var) results in a compilation error.

The keyword tt(auto) is frequently used in situations where it is very hard to
determine the variable's type. These situations are encountered, e.g., in the
context of em(templates) (cf. chapters ref(STL) until ref(ADVANCEDTEMPL).

At this point in the Annotations only simple examples can be given.  Refer to
section ref(AUTODECL) for additional information about tt(auto) (and the
related tt(decltype) function).

When defining and initializing a variable tt(int variable = 5) the type of the
initializing expression is well known: it's an tt(int), and unless the
programmer's intentions are different this could be used to define
tt(variable)'s type (a somewhat contrived example as in this case it
reduces rather than improves the clarity of the code):
        verb(
    auto variable = 5;
        )

    However, here are some examples where tt(auto) can profitably be used.  In
chapter ref(String) the emi(iterator) concept is introduced (see also chapters
ref(CONTAINERS) and ref(STL)). Iterators sometimes have long type definitions,
like
        verb(
    std::vector<std::string>::const_reverse_iterator
        )
    Functions may return types like this. Since the compiler knows the
types returned by functions we may exploit this knowledge by using
tt(auto). Assume that a function tt(begin()) is declared like this:
        verb(
    std::vector<std::string>::const_reverse_iterator begin();
        )
    Rather than writing the verbose variable definition (at tt(//
1), below) a much shorter definition (at tt(// 2)) can be used:
        verb(
    std::vector<std::string>::const_reverse_iterator iter = begin();    // 1
    auto iter = begin();                                                // 2
        )
    It's easy to define additional variables of this type. When initializing
those variables using tt(iter) the tt(auto) keyword can again be used:
        verb(
    auto start = iter;
        )
    When defining variables using tt(auto) the variable's type is deduced from
the variable's initializing expression. Plain types and pointer types are used
as-is, but when the initializing expression is a reference type, then the
reference's basic type (without the reference, and omitting tt(const) or
tt(volatile) specifications) is used.

If a reference type is required then ti(auto &) or tt(auto &&) can be
used. Likewise, tt(const) and/or pointer specifications can be used in
combination with the tt(auto) keyword itself. Examples:
        verb(
    int value;
    auto another = value;   // value is int, so 'int another' is defined

    string const &text();
    auto str = text();      // text's plain type is string, so 
                            // string str, NOT string const str
                            // is defined
    str += "...";           // OK

    int *ip = &value;
    auto ip2 = ip;          // int *ip2, pointing at value, is defined.

    int *const &ptr = ip;
    auto ip3 = ptr;         // int *ip3 is defined, omitting const &
    auto const &ip4 = ptr;  // int *const &ip4 is defined.
        )







