So our flight simulator program uses two tt(ErrorCodeEnums): one covering
errors that are related to the simulator itself, and one covering errors
related to its on-board calculator. If we're using facilities provided by
libraries then several more enums might also be available for use in our
simulator. E.g., there could be a data base of airport approach charts,
defining an tt(ApproachChartError) enum, and the simulator's GPS might come
with its own tt(GPGErrors) enum.

Errors can usually be categorized. In our simulator we might recognize user
input errors, unavailable requests, system failures, etc..
hi(error_condition)em(Error_conditions) allow us to categorize
tt(ErrorCodeEnums) errors without using tt(if)-statements testing specific
enum values. Error conditions em(could) be (and often em(are)) implemented
like error categories: an enumeration is defined, which is then `upgraded' to
a tt(std::error_condition).

The disadvantage of using enumerations across independent developers is that
enumerations are difficult to apply, combine, and extend: a library might
define an tt(InputError) condition but another library might do so as well;
different enums might be available, but how do we prevent those enums from
using identical values?

Such problems might be prevented by avoiding fixed enum values, and instead
use verbal labels denoting error conditions. So rather than specifying
        verb(
    enum class ErrorCondition
    {
        InputCond,
        SimCond,
        Calc


Let's define our conditions as:
    verbinsert(-s4 //simerrsrc examples/errcodeenum.cc)
    This allows us to distinguish errors made by the user, errors from the
calculator, and errors from the simulator. As in the previous section, we'll
`promote' this enum, this time to an ti(ErrorConditionEnum):
    verbinsert(-s4 //simcondtrait examples/errcodeenum.cc)

Now that an error condition enumeration has been defined, error codes can be
mapped to their appropriate error condition values. To do that, a tt(class
ErrorSourceCategory) is derived (again: in the anonymous namespace) from
tt(std::error_category), similarly to what we did before with, e.g.,
tt(CalculatorErrCategory):
        verbinsert(-s4 //errorourcecat examples/errcodeenum.cc)

    The tt(name) and tt(message) members are defined as before, but in
addition the member tt(equivalent) is defined comparing a received
tt(error_code) to the available tt(SimErrSource) values. The function
tt(equivalent) returns tt(true) if tt(error_code code) can be mapped to tt(int
condition), which in fact is a statically cast tt(SimErrSource) value. For tt(
