    The compiler uses the following i(algorithm) to deduce the actual types of
        hi(template parameter deduction)
its template type parameters:
    itemization(
    it() In turn, the template function's parameters are identified using the
arguments of the called function.
    it() For each template parameter used in the template function's parameter
list, the template type parameter is matched with the corresponding argument's
type (e.g., tt(Type) is tt(int) if the argument is tt(int x), and the
function's parameter is tt(Type &value)).
    it() While matching the argument types to the template type parameters,
the three allowed transformations (see section ref(TEMPFUNARGS)) for template
type parameters are applied where necessary.
    it() If identical template type parameters
        hi(template parameters: identical types)
    are used with multiple function parameters, the deduced template types
must be exactly the same. So, the next template function cannot be called with
an tt(int) and a tt(double) argument:
        verb(
    template <typename Type>
    Type add(Type const &lvalue, Type const &rvalue)
    {
        return lvalue + rvalue;
    }
        )
    When calling this template function, two identical types must be used
(albeit that the three standard transformations are of course allowed). If the
template deduction mechanism does not come up with identical actual types for
identical template types, then the template function will not be instantiated.
    )
