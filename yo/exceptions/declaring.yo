Functions defined elsewhere may be linked to code using these
functions. Such functions are normally declared in header files, either as
i(stand alone functions) or as i(member functions) of a class.

These external functions may of course throw exceptions. Declarations of
such functions may contain a emi(function throw list) or
    emi(exception specification list), in which the types of the exceptions
that can be thrown by the function are specified. For example, a function that
could throw `tt(char *)' and `tt(int)' exceptions can be declared as
        verb(
    void exceptionThrower() throw(char *, int);
        )
    If specified, a function throw list appears immediately beyond the
function header (and also beyond a possible tt(const) specifier), and,
noting that throw lists may be empty, it has the following generic form:
        ti(throw([type1 [, type2, type3, ...]]))

    If a function em(doesn't) throw exceptions an i(empty function throw list)
may be used. E.g.,
        verb(
    void noExceptions() throw ();
        )
    In all cases, the function header used in the function definition must
exactly match the function header that is used in the declaration, e.g.,
including a possible empty function throw list.

    A function for which a function throw list is specified may not throw
other types of exceptions. A emi(run-time error) occurs if it tries to throw
other types of exceptions than those mentioned in the function throw list.

    For example, consider the declarations and definitions in the following
program:
        verbinclude(exceptions/examples/throwlist.cc)
    In the function tt(charPintThrower()) the tt(throw) statement clearly
throws a tt(char const *). However, since tt(intThrower()) may throw an
tt(int) exception, the function throw list of tt(charPintThrower()) must
em(also) contain tt(int).

If the function throw list is not used, the function may either throw
exceptions (of any kind) or not throw exceptions at all. Without a function
throw list the responsibility of providing the correct handlers is in the
hands of the program's designer.

Declaring exception throwers is for various reason a questionable
activity. Declaring exception throwers does not mean that the compiler will
check whether an improper exception is thrown. Rather, the function will be
surrounded by additional code in which the actual exception that is thrown is
processed. So, instead of compile time checks one gets run-time overhead as
well as extra code added to the function's code. The prototypical
implementation of a function having an exception throw list (e.g., tt(throw
(int))) is:
        verb(
    function fun() throw (int)
    try                         // this code resulting from throw(int)
    {
        // code of this function, throwing all kinds of exceptions
    }
    catch (int)                 // remaining code resulting from throw(int)
    {
        throw;  // rethrow the exception, so it can be caught by the
                // `intended' handler
    }
    catch (...) // catch all other exceptions
    {
        throw bad_exception;    
    }
        )
    (see section ref(STDEXC) for a description of ti(bad_exception)). The
run-time overhead is caused by doubling the number of thrown and caught
exceptions. Without a throw list a thrown tt(int) is simply caught by its
intended handler; with a throw list the tt(int) is em(first) caught by the
`safeguarding' handler added to the function. Inside that handler it is now
em(rethrown) to be caught only thereafter by the intended handler.
