A ti(catch) clause consists of the keyword tt(catch) followed by a parameter
list defining one parameter specifying type and (parameter) name of the
exception the tt(catch) handler will catch. This name may then be used as a
variable in the compound statement following the tt(catch) clause.
Example:
        verb(
    catch (string &message)
    {
        // code to handle the message
    }
        )
    Primitive types and objects may be thrown as exceptions. It's a
bad idea to throw a pointer or reference to a local object, but a pointer to a
em(dynamically) allocated object may be thrown as the exception handler will
be able to delete the allocated memory thus preventing a i(memory
leak). Throwing such a pointer is still dangerous as the exception handler
will not be able to distinguish dynamically allocated memory and
non-dynamically allocated memory, as illustrated by the next example:
        verb(
    try
    {
        int x;
        int *xp = &x;

        if (condition1)
            throw &xp;

        xp = new int(0);
        if (condition2)
            throw xp;
    }
    catch (int *ptr)
    {
        // delete ptr or not?
    }
        )
    Close attention should be paid to the nature of the parameter of the
exception handler, to make sure that when pointers to dynamically allocated
memory are thrown the memory is returned  once the handler has processed
the pointer. In general pointers should not be thrown as exceptions. If
dynamically allocated memory must be passed to a exception handler then the
pointer should be wrapped in a smart pointer, like tt(unique_ptr) or
tt(shared_ptr) (cf. sections ref(UNIQUEPTR) and ref(SHAREDPTR)).

    Multiple tt(catch) handlers may follow a tt(try) block, each handler
defining its own exception type.  The em(order) hi(exception handler: order)
of the exception handlers is important. When an exception is thrown, the first
exception handler matching the type of the thrown exception is used and
remaining exception handlers are ignored. Eventually at most one exception
handler following a tt(try)-block will be used. Normally this is of no
concern as each exception has its own unique type. 

    Example: if exception handlers are defined for tt(char *)s and ti(void *)s
then ASCII-Z strings will be caught by the former handler. Note that a tt(char
*) can also be considered a tt(void *), but the exception type matching
procedure is smart enough to use the tt(char *) handler with the thrown
ASCII-Z string. Handlers should be designed very type specific to catch the
correspondingly typed exception. For example, tt(int)-exceptions are not
caught by tt(double)-catchers, tt(char)-exceptions are not caught by
tt(int)-catchers. Here is a little example illustrating that the order of the
catchers is not important for types not having any hierarchal relationship to
each other (i.e., tt(int) is not derived from tt(double); tt(string) is not
derived from ASCII-Z):
COMMENT(>>>>>>>>>>>>> NEXT <<<<<<<<<<<<<)
        verbinclude(exceptions/examples/catchers.cc)
    As an alternative to constructing different types of exception handlers
for different types of exceptions, a specific class can be designed whose
objects contain information about the exception. Such an approach was
mentioned earlier, in section ref(EMPTYTHROW). Using this approach, there's
only one handler required, since we em(know) we won't throw other types of
exceptions:
        verb(
    try
    {
        // code throws only Exception pointers
    }
    catch (Exception *e)
    {
        e->process();
        delete e;
    }
        )
    The tt(delete e) statement in the above code  indicates
that the tt(Exception) object was created dynamically.

When the code of an exception handler has been processed, execution continues
beyond the last exception handler directly following that tt(try)-block
(assuming the handler doesn't itself use flow control statements (like
tt(return) or tt(throw)) to break the default flow of execution). From this,
we distinguish the following hi(exception: cases) cases:
    itemization(
    it() If em(no) exception was thrown within the tt(try)-block no exception
handler is activated, and the execution continues from the last statement in
the tt(try)-block to the first statement beyond the last tt(catch)-block.
    it() If an exception em(was) thrown within the tt(try)-block but neither
the current level nor an other level contains an appropriate exception
handler, the program's i(default exception handler) is called, usually
aborting the program.
    it() If an exception was thrown from the tt(try)-block and an appropriate
exception handler is available, then the code of that exception handler is
executed. Following the execution of the code of the exception handler, the
execution of the program continues at the first statement beyond the last
tt(catch)-block.
    )
    All statements in a tt(try) block appearing below an executed
tt(throw)-statement will be hi(try block: ignoring statements)
ignored. However, destructors hi(try block: destructors in) of objects defined
locally in the tt(try)-block em(are) called, and they are called before any
exception handler's code is executed.

The actual hi(exception: construction of) computation or construction of an
exception may be implemented using various degrees of sophistication. For
example, it's possible to use the operator tt(new); to use static member
functions of a class; to return a pointer to an object; or to use objects of
classes derived from a class, possibly involving polymorphism.
