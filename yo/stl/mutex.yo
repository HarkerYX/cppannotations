    i(C++0x) offers a series of i(mutex) classes to protect shared
data. Apart from the tt(std::mutex) class a emi(std::recursive_mutex) is
offered: when called multiple times by the same thread it will increase its
lock-count. Before other threads may access the protected data the recursive
mutex must be unlocked again that number of times. In addition 
ti(std::timed_mutex) and ti(recursive_timed_mutex) is offered: their locks
will time out after a preset amount of time.

    In many situations locks will be released at the end of some action
block. To simplify locking additional template classes 
ti(std::unique_lock<>) and ti(std::lock_guard<>) are provided. As their
constructor locks the data and their destructor unlocks the data they can be
defined as local variables, unlocking their data once their scope terminates.
Here is a simple example showing its use; at the end of tt(safeProcess guard)
is destroyed, thereby releasing the lock on tt(data):
        verb(
    std::mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::lock_guard<std::mutex> guard(dataMutex);
        process(data);
    }
        )
A tt(std::unique_lock) is used similarly, but is used when timeouts must be
considered as well:
        verb(
    std::timed_mutex dataMutex;
    Data data;

    void safeProcess()
    {
        std::unique_lock<std::timed_mutex> 
            guard(dataMutex, std::chrono::milliseconds(3));
        if (guard)
            process(data);
    }
        )
    In the above example tt(guard) tries to obtain the lock during three
milliseconds. If tt(guard)'s tt(bool) conversion operator returns tt(true) the
lock was obtained and tt(data) can be processed safely.

A common cause of problems with multi threaded programs is the occurrence of
i(deadlock)s. If a deadlock may occur when two locks are required to process
data, but one thread obtains the first lock and another thread obtains the
second lock. The C++0x standard defines a generic ti(std::lock) function that
may be used to prevent problems like these. The tt(std::lock) function
can be used to lock multiple mutexes in one atomic action. Here is an example:
        verb(
    struct SafeString
    {
        std::mutex  d_mutex;
        std::string d_text;
    };

    void calledByThread(SafeString &first, SafeString &second)
    {
        std::unique_lock<std::mutex>                        // 1
                lock_first(first.d_mutex, std::defer_lock);

        std::unique_lock<std::mutex>                        // 2
                lock_second(second.d_mutex, std::defer_lock);

        std::lock(lock_first, lock_second);                 // 3

        safeProcess(first.d_text, second.d_text);
    }
        )
    At 1 and 2 unique_locks are created. Locking is deferred until calling
tt(std::lock) in 3. Having obtained the lock, the two tt(SafeString) text
members can both be safely processed by tt(calledByThread).

Another problematic issue with threads involves initialization. If multiple
threads are running and only the first thread encountering the initialization
code should perform the initialization then this problem should not be solved
by mutexes. Although the synchronization is accomplished, it will needlessly 
be accomplished time and again once the initialization phase has been
completed. The C++0x standard offers several ways to perform a proper
initialization: 
    itemization(
    it() First, a emi(constexpr) em(constructor) may be defined. Constexpr
constructors are currently not yet supported by the tt(g++) compiler and its
discussion is therefore postponen.
    COMMENT(
First, suppose your constructor is declared with the new constexpr keyword and
satisfies the requirements for constant initialization. In this case, an
object of static storage duration, initialized with that constructor, is
guaranteed to be initialized before any code is run as part of the static
initialization phase. This is the option chosen for std::mutex, because it
eliminates the possibility of race conditions with initialization of mutexes
at a global scope:


class my_class
    {
        int i;

    public:
        constexpr my_class():i(0){}

        my_class(int i_):i(i_){}

        void do_stuff();
    };

    my_class x; // static initialization with constexpr constructor

    int foo();
    my_class y(42+foo()); // dynamic initialization

    void f()
    {
        y.do_stuff(); // is y initialized?
    }
        END)

    it() Second, a static variable defined within a compound statement may be
used (e.g., a static local variable within a function body). 
        hi(static local variables)
        hi(compound stmnt: static variables within)
    block scope may be used.  In C++ static variables defined within a compund
statement are initialized the first time the function is called at the point
in the code where the static variable is defined as illustrated by the
following example:
        verbinclude(stl/examples/staticlocal.cc)
    This feature causes a thread to wait automatically if another thread is
still initializing the static data (note that em(non-static) data never cause
problems, as each non-static local variables have lifes that are completely
restricted to their own threads).
    it() If the above two approaches can't be used. The combined use of
tt(std::call_once) and tt(std::once_flag) result in the one-time execution of
a specified function as illustrated by the next example:
        verb(
    std::string *global;
    std::once_flag globalFlag;

    void initializeGlobal()
    {
        global = new std::string("Hello world (why not?)");
    }

    void safeUse()
    {
        std::call_once(globalFlag, initializeGlobal);
        process(*global);
    }
        )
    )

Mutexes may be used in C++0x after including the header file
        hi(#include <mutex>)
    ti(mutex).
