In this section we consider a classic producer-consumer scenario: the producer
generates items to be consumed by a consumer. The producer can only produce a
certain number of items before its storage capacity has filled up and the
client cannot consume more items than the producer has produced.

At some point the producer will have to wait until the client has consumed
enough so there's again space available in the producer's storage. Similarly,
the client has to wait until the producer has produced at least some items.

Locking and polling the amount of available items/storage at fixed time
intervals usually isn't a very attractive option as it wastes resources.
Threads continue to wait during the full interval even though continuation
might already have been possible. The interval could be reduce, but that too
isn't an attractive option, as it results in needlessly increasing the
overhead associated with handling the associated mutexes.


Condition variables hi(condition_variable) may be used to solve these kinds of
problems. Condition variables allow us to block a thread until notified by
some other thread or until a preset amount of time has been passed (or a
preset point in time has been reached).

Before using condition variables the tthi(condition_variable) header file must
have been included.

Condition variables come in two flavors: objects of the class 
    hi(condition_variable)tt(std::condition_variable) 
are used in combination with objects of type tt(unique_lock<mutex>), which may
result in an increased efficiency compared to the efficiency that can be
obtained with objects of the class
    hi(condition_variable_any)tt(stdLLcondition_variable_any) that can be used
with any (e.g., user-supplied) lock types.

The condition variable classes offer members like tt(wait, wait_for,
wait_until, notify_one) and tt(notify_all) that may concurrently be called.
The notify members are always atomically executed. The execution of the
wait members consists of three atomic parts:
    itemization(
    it() the mutex's release, and subsequent entry into the waiting state;
    it() unblocking the wait state;
    it() reacquisition of the lock.
    )

A program using condition variables may not assume any order in the execution
of the tt(notify_one, notify_all), and in the execution of each part of
the tt(wait, wait_for), and tt(wait_until) members.

In addition to the condition variable classes the following free function and
tt(enum) type are provided:
    itemization(
    ithtq(notify_all_at_thread_exit)(void std::notify_all_at_thread_exit(
            condition_variable &cond, unique_lock<mutex> lockObject))
       (this function transfers ownership of the lock associated with
        tt(lockObject) into internal storage. Once the current thread has
        terminated and all objects that were defined during this thread have
        been destroyed, the condition variable tt(cond) will be notified, as
        if by calling
       verb(
   lockObject.unlock();
   cond.notify_all();
        )
       After calling tt(notify_all_at_thread_exit) the thread should exit as
        soon as possible, avoiding any blocking or time-consuming tasks.

       Waiting threads must also verify that the thread they were waiting for
        has indeed been finished. This is usually done by obtaining the lock
        on tt(lockObject), after which they verify that the condition they
        were waiting for is true, and that this lock was not released and
        reacquired prior to calling tt(notify_all_at_thread_exit).  )
    it() hi(cv_status)
        verb(
    namespace std
    {
        enum class cv_status 
        { 
            no_timeout, 
            timeout 
        };
    }
        )
    )

The class tt(condition_variable) offers a default constructor, but no copy
constructor or overloaded assignment operator. 

The class's destructor requires that no thread is blocked by the current
thread. This implies that all other threads have been notified; those
threads may subsequently block on the lock specified in the wait. 

The class tt(condition_variable)'s members are:
    itemization(
    ithtq(notify_one)(void notify_one() noexcept)
       (if at least one thread is blocked because it is waiting for the
        current thread, one of them is unblocked)
    ithtq(notify_all)(void notify_all() noexcept)
       (all thread that are blocked, waiting for the current thread are
        unblocked)
    ithtq(wait)(void wait(unique_lock<mutex>& lockObject))
       (When returning from this member tt(lockObject) is locked by the
        calling thread. However, it may also spuriously unblock, without
        having locked tt(lockObject).)

template <class Predicate>
  void wait(unique_lock<mutex>& lock, Predicate pred);
template <class Clock, class Duration>
  cv_status wait_until(unique_lock<mutex>& lock,
                        const chrono::time_point<Clock, Duration>& abs_time);
template <class Clock, class Duration, class Predicate>
  bool wait_until(unique_lock<mutex>& lock,
                  const chrono::time_point<Clock, Duration>& abs_time,
                  Predicate pred);
template <class Rep, class Period>
  cv_status wait_for(unique_lock<mutex>& lock,
                      const chrono::duration<Rep, Period>& rel_time);
template <class Rep, class Period, class Predicate>
  bool wait_for(unique_lock<mutex>& lock,
                const chrono::duration<Rep, Period>& rel_time,
                Predicate pred);
    )


condition_variable_any();
~condition_variable_any();
condition_variable_any(const condition_variable_any&) = delete;
condition_variable_any& operator=(const condition_variable_any&) = delete;
void notify_one() noexcept;
void notify_all() noexcept;
template <class Lock>
  void wait(Lock& lock);
template <class Lock, class Predicate>
  void wait(Lock& lock, Predicate pred);
template <class Lock, class Clock, class Duration>
  cv_status wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time);
template <class Lock, class Clock, class Duration, class Predicate>
  bool wait_until(Lock& lock, const chrono::time_point<Clock, Duration>& abs_time, Predicate pred);
template <class Lock, class Rep, class Period>
  cv_status wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time);
template <class Lock, class Rep, class Period, class Predicate>
  bool wait_for(Lock& lock, const chrono::duration<Rep, Period>& rel_time, Predicate pred);




Condition variables hi(condition_variable) may be used to solve these kinds of
problems. A thread simply sleeps until it is notified by another
thread. Generally this may be accomplished as follows:
    verb(
    producer loop:
        - produce the next item
        - wait until there's room to store the item,
            then reduce the available storage
        - store the item
        - increment the number of items in store

    consumer loop:
        - wait until there's an item in store,
            then reduce the number of items in store
        - remove the item from the store
        - increment the number of available storage locations
        - do something with the retrieved item
    )

It is important that the two storage administrative tasks (registering the
number of available items and available storage locations) are either
performed by the client or by the producer. `Waiting' in this case means:
    itemization(
    it() Get a lock on the variable containing the actual count
    it() As long as the count is zero: wait, release the lock until
        another thread has increased the count, re-acquire the lock.
    it() Reduce the count
    it() Release the lock.
    )
    To implement this scheme a ti(condition_variable) is used. The variable
containing the actual count is called a ti(semaphore) and it can be protected
using a tt(mutex sem_mutex). In addition a tt(condition_variable condition) is
defined. The waiting process is defined in the following function tt(down)
implemented as follows:
        verb(
    void down()
    {
        unique_lock<mutex> lock(sem_mutex);   // get the lock
        while (semaphore == 0)
            condition.wait(lock);           // see 1, below.
        --semaphore;                        // dec. semaphore count
    }                                       // the lock is released
        )
    At 1 the condition variable's tt(wait) member internally releases the
lock, waits for a notification to continue, and re-acquires the lock just
before returning. Consequently, tt(down)'s code always has complete and
unique control over tt(semaphore).

    What about notifying the condition variable? This is handled by the
`increment the number ...' parts in the abovementioned produced and consumer
loops. These parts are defined by the following tt(up) function:
        verb(
    void up()
    {
        lock_guard<std::mutex> lock(sem_mutex); // get the lock
        if (semaphore++ == 0)
            condition.notify_one();             // see 2, below
    }                                           // the lock is released
        )
    At 2 tt(semaphore) is always incremented. However, by using a postfix
increment it can be tested for being zero at the same time and if it was zero
initially then tt(semaphore) is now one. Consequently, the thread waiting for
tt(semaphore) being unequal to zero may now
continue. tt(Condition.notify_one)hi(notify_one) notifies a waiting thread
(see tt(down)'s implementation above). In situations where multiple threads
are waiting `ti(notify_all)' can be used.

    Handling tt(semaphore) can very well be encapsulated  in a class
tt(Semaphore), offering members tt(down) and tt(up). For a more extensive
discussion of semaphores see i(Tanenbaum, A.S.) (2006)
    i(Structured Computer Organization), Pearson Prentice-Hall.

    Using the semaphore facilities of the class tt(Semaphore) whose
constructor expects an initial value of its tt(semaphore) data member, the
classic producer and consumer case can now easily be implemented in the
following multi-threaded program+footnote(A more elaborate example of the
producer-consumer program is found in the tt(yo/stl/examples/events.cc) file
in the bf(C++) Annotations's source archive):
        verb(
    Semaphore available(10);
    Semaphore filled(0);
    std::queue itemQueue;

    void producer()
    {
        size_t item = 0;
        while (true)
        {
            ++item;
            available.down();
            itemQueue.push(item);
            filled.up();
        }
    }
    void client()
    {
        while (true)
        {
            filled.down();
            size_t item = itemQueue.front();
            itemQueue.pop();
            available.up();
            process(item);      // not implemented here
        }
    }

    int main()
    {
        thread produce(producer);
        thread consume(consumer);

        produce.join();
        return 0;
    }
        )

COMMENT(

You still need to check that the data is ready though, since condition
variables can suffer from what are called spurious wakes: The call to wait()
may return even though it wasn't notified by another thread. If you're worried
about getting this wrong, you can pass that responsibility off to the standard
library too, if you tell it what you're waiting for with a predicate. The new
C++11 lambda facility makes this really easy:
    void foo()
    {
        std::unique_lock<std::mutex> lk(m);
        cond.wait(lk,[]{return data_ready;});
        process_data();
    }
END)

To use tt(condition_variable) objects the header file
    ti(condition_variable)hi(#include <condition_variable>) must be included.
