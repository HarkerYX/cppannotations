In bf(C++) (member) function pointers have fairly strict targets: these
pointers may only point to (member) functions of their (class) scope. 
However when defining templates the (class) type of the function pointer may
vary from instantiation to instantiation. 

To accomodate for these situations the i(C++0x standard) introduces
em(polymorphous (function object) wrappers).hi(polymorphous wrappers)
Polymorphous wrappers can refer to function pointers, member functions or
functors, as long as they match in type and number of their parameters.

Polymorphous wrappers are not yet fully supported by the tt(g++) compiler.

COMMENT(

function<int ( int, int )> pF ;  // Wrapper creation using
                                 // template class 'function'.
 
plus<int> add ;  // 'plus' is declared as 'template<class T> T plus( T, T ) ;'
                 // then 'add' is type 'int add( int x, int y )'.
 
pF = &add ;  // OK - Parameters and return types are the same.
 
int a = pF( 1, 2 ) ;  // NOTE: if the wrapper 'pF' does not refer to any function,
                      // the exception 'std::bad_function_call' is thrown.
 
function<bool ( short, short )> pG ;
if( !pG )  // Always true because 'pG' has not yet
           // been assigned a function.
{
  bool adjacent( long x, long y ) ;
  pG = &adjacent ;  // OK - Parameters and return types are convertible.
 
  struct test
  {
    bool operator()( short x, short y ) ;
  } car ;
  pG = ref(car) ;  // 'ref' is a template function that returns the wrapper
                   // of member function 'operator()' of struct 'car'.
}
pF = pG ;  // OK - Parameters and return types are convertible.

The template class function will be defined inside the header <functional>, and doesn't require any changes to the C++ language.

END)


