The basic form to hi(unique_ptr: initialization) initialize an tt(unique_ptr)
object is to provide its constructor with a block of memory allocated
by ti(operator new) operator. The generic form is:
        verb(
    unique_ptr<type [, deleter_type]> identifier(new-expression
            [, deleter = deleter_type()]);
        )
    The second (template) argument (tt(deleter(_type))) is optional and may
        hi(deleter class)
refer to a class/object handling the destruction of the allocated memory. This
is used, e.g., in situations where a double pointer is allocated and the
destruction must visit each nested pointer to destroy the memory it points
at (see below).

    Here is an example initializing an tt(unique_ptr) pointing to a tt(string)
object:
        verb(
    unique_ptr<string> strPtr(new string("Hello world"));
        )
    To initialize an tt(unique_ptr) to point to a tt(double) value the
following construction can be used:
        verb(
    unique_ptr<double> dPtr(new double(123.456));
        )
    Note the use of tt(operator new) in the above expressions. Using tt(new)
ensures the dynamic nature of the memory pointed to by the tt(unique_ptr)
objects and allows the deletion of the memory once tt(unique_ptr) objects go
i(out of scope). Also note that tt(type) does em(not) mention the pointer:
the hi(unique_ptr: used type) type used in the tt(unique_ptr) construction
is the same as used in tt(new) expressions.

The next example shows how an explicitly defined deleter may be used to delete
a dynamically allocated array of pointers to strings. Instead of using a
template value parameter the deleter's constructor could of course also be
given a parameter initializing the deleter with the number of elements to
delete:
        verbinclude(stl/examples/deleter.cc)

In the example allocating an tt(int) values given in section ref(UNIQUEPTR),
the memory leak can be avoided using an tt(unique_ptr) object:
        verb(
    #include <memory>
    using namespace std;

    void fun()
    {
        unique_ptr<int> ip(new int);
    }
        )
    All hi(unique_ptr: reaching members) member functions  available for
objects allocated by the tt(new) expression can be reached via the
tt(unique_ptr) as if it was a plain pointer to the dynamically allocated
object. For example, in the following program the text `tt(C++)' is inserted
behind the word `tt(hello)':
        verbinclude(stl/examples/insertcpp.cc)
