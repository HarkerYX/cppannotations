One of the problems using pointers is that strict i(bookkeeping) is required
with respect to their memory use and lifetime. When a pointer variable goes
    i(out of scope), the memory pointed to by the pointer is suddenly
inaccessible, and the program suffers from a i(memory leak). For example, in
the following function tt(fun()), a memory leak is created by calling
tt(fun()): the allocated tt(int) value remains inaccessibly allocated:
        verb(
    void fun()
    {
        new int;
    }
        )
    To prevent memory leaks strict bookkeeping is required: the programmer has
to make sure that the memory pointed to by a pointer is deleted just before
the pointer variable goes i(out of scope). The above example could easily be repaired:
        verb(
    void fun()
    {
        delete new int;
    }
        )
    Now tt(fun()) merely wastes some time.

    When a pointer variable points to em(a single value or object), the
bookkeeping requirements may be relaxed when the pointer variable is defined
as a tt(std::unique_ptr)hi(unique_ptr) object. Unique_ptrs are em(objects),
masquerading as pointers. Since they're objects, their destructors are called
when they go out of scope, and because of that, their destructors will take
the responsibility of deleting the dynamically allocated memory.

Before tt(unique_ptrs) can be used the following preprocessor directive must
have been specified:hi(#include <memory>)
        verb(
    #include <memory>
        )
    Normally, an tt(unique_ptr) object is initialized with a dynamically
created value or object.

    The following should be considered when using tt(unique_ptr)s:
    itemization(
    it() when assigning a tt(unique_ptr) to another em(move semantics) is
used. If move semantics are not available compilation will fail. On the other
hand, if compilation succeeds then the used containers or generic algorithms
support the use of tt(unique_ptr)s. Here is an example:
        verb(
    std::unique_ptr<int> up1(new int);
    std::unique_ptr<int> up2 = up1;      // compilation error
        )
    The second definition fails to compile since tt(unique_ptr)'s copy
constructor is private (the same holds true for the assignment
operator). The tt(unique_ptr) class em(does) offer facilities to initialize
and assign from em(rvalue references):
        verb(
    class unique_ptr                        // interface partially shown 
    {
        public:
            unique_ptr(unique_ptr &&other); // rvalues bind here
        private:
            unique_ptr(const unique_ptr &other);
    };
        )
    Consequently, in the above example move semantics should be used. E.g.,
        verb(
    std::unique_ptr<int> up1(new int);
    std::unique_ptr<int> up2 = std::move(up3); 
        )
    it() a tt(unique_ptr) object should only point to memory that was made
available dynamically, as only i(dynamically allocated memory) can be deleted.
    it() multiple tt(unique_ptr) objects should not be allowed to point to the
same block of dynamically allocated memory. The tt(unique_ptr)'s interface was
designed to prevent this from happening. Once an tt(unique_ptr) object goes out
of scope, it deletes the memory it points to, immediately changing any other
object also pointing to the allocated memory into a hi(wild pointer) wild
pointer.
    )
    The tt(class unique_ptr) defines several member functions
to access the pointer itself or to have the tt(unique_ptr) point to another
block of memory. These member functions and ways to construct tt(unique_ptr)
objects are discussed in the next sections.

tt(Unique_ptr)s become available in tt(g++ 4.4).
