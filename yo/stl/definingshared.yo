There are three ways to hi(shared_ptr: defining) define tt(shared_ptr)
objects. Each definition contains the usual tt(<type>) specifier between
angle brackets. Concrete examples are given in the coming sections, but an
overview of the various possibilities is presented here:
    itemization(
    it() The basic form initializes an tt(shared_ptr) object to point to a block
of memory allocated by the tt(new) operator:
        verb(
    shared_ptr<type> identifier (new-expression [, deleter]);
        )
    This form is discussed in section ref(SHAREDNEW).

    it() Shared pointers support copy construction. When copy constructing a
shared pointer both tt(shared_ptr) objects point at the same memory, and the
object's reference count is incremented.

    it() Another form initializes an tt(shared_ptr) object using em(move
semantics), either supported by the data type itself or forced using
tt(std::move):
        verb(
    // type must support move semantics or std::move(other) must be used
    shared_ptr<type> identifier(another shared_ptr for type);
        )
    This form is discussed in section ref(SHAREDMOVE).
    it() The third form simply creates an tt(shared_ptr) object that
does not point to a particular block of memory:
        verb(
    shared_ptr<type> identifier;
        )
    This form is discussed in section ref(SHAREDPLAIN).
    )
