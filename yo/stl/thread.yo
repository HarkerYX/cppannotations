In bf(C++) multi threading can be realized through the use of objects of the
class hi(thread)tt(std::thread). Each object of this class handles a separate
em(thread of execution).

Before using tt(Thread) objects the tthi(thread) header file must have been
included.

Threads can be em(joined), i.e., wait until another thread has finished, and
the em(states) of threads may be queried and controlled by a multi-threaded
program.

Each tt(thread) object represents one unique thread of execution, but its
unique thread may be transferred to another tt(thread) object. In this
situation there remains but a single tt(thread) object that represents the
running thread.

If a threads of execution loses its association with a tt(thread) object that
thread is said to be hi(thread: detached) em(detached). Conversely, tt(thread)
objects by themselves are not necessarily associated with a running thread of
execution: following the default construction, a move operation in which a
tt(thread) object acts as  the source tt(thread) or after detaching or joining
threads the tt(thread) object may still exist, albeit in a state where it is
not or no longer associated with a running thread.

The class tt(thread) offers the following constructors:
    itemization(
    itt(thread() noexcept):
       the default constructor creates a tt(thread) object that is not (yet)
        associated with a running thread of execution;
    itt(explicit thread(Fun &&fun, Args &&...args)):
       this constructor is defined as a em(member template) (cf. section
        ref(MEMTEMP)), using the template header tt(template <class F, class
        ...Args>). Its first argument is a function that implements the
        thread's actions. The notation tt(Args &&...args) indicates that any
        number of additional arguments may follow tt(fun). These arguments are
        then passed with their proper types and values to tt(fun). The
        argument passed to tt(fun) may also be a function object, whose
        function call operator then receives the tt(...args) arguments.

       Function (or function object) and arguments must be 
       emi(move constructible) (i.e., after assignment or initialization the
        target object is equivalent to the original source, while following
        the assignment or construction the source's state is not
        specified). After (move-)constructing copies of tt(fun) and
        tt(...args) the tt(thread) object has been constructed. Following the
        tt(thread) object construction (but not as part of the construction),
        a separately running thread of execution, associated with the just
        constructed tt(thread) object, is started.

       If the requested thread cannot be created a tt(system_error) is
        thrown. 
    itt(thread(thread &&tmp) noexcept):
       The move constructor uses tt(tmp) to construct the target tt(thread)
        object and puts tt(tmp) in the tt(thread)'s default state.
    )

    When a tt(thread) object is destroyed while its thread of execution is
still active, tt(terminate) is called, forcing the program's end. So, before
calling a tt(thread) object's destructor its thread of execution must have
been terminated. This is accomplished by ending the function which was passed
to the tt(thread) object's constructor.

    In the following example a tt(thread) object is created, inserting the
text tt(hello world) three times into tt(cout):
        verbinclude(examples/hellothread.cc)

The members of the class tt(thread) are:
    itemization(
    ithtq(detach)(void detach())
       (requires tt(joinable) to return tt(true).  The thread for which
        tt(detach) is called continues its execution. The (e.g., parent)
        thread calling tt(detach) continues its execution immediately beyond
        the tt(detach)-call.  After calling tt(object.detach()), `tt(object)'
        no longer represents the, possibly still continuing but now detached,
        thread of execution. It is the detached thread's implementation's
        responsibility to release its resources when its execution ends. 

        Since tt(detach) disconnects a thread from the running program, e.g.,
        tt(main) no longer can wait for the thread's completion.  As a program
        ends when tt(main) ends, its still running threads also stop, and
        program may not properly complete all its threads, as demonstrated by
        the following program: verbinclude(examples/twothreads.cc). When this
        porgram is run, only part of the potentially generated output is
        inserted into tt(cout), like:
            verb(
    leaving22: hello world
            )
        )
    ithtq(get_id)(id get_id() const noexcept)
       (If the current object does not represent a a running thread a default
        tt(id) object is returned. Otherwise, tt(this_thread::get_id()) is
        returned for the running thread that is associated with the object for
        which tt(get_id) is called is returned.)
    ithtq(join)(void join())
       (requires tt(joinable) to return tt(true).  Blocks the thread calling
        tt(join) until the thread for which tt(join) is called has
        completed. Following its completion the object whose tt(join) member
        was called no longer represents a running thread, and its tt(get_id)
        member will return the default tt(id).nl()
       An example of its use is provided by the above example. In that example
        tt(join) is called to prevent tt(display) from being destroyed at the
        end of tt(main). Without calling tt(join) tt(display)'s thread would
        still have been running by the time tt(main)'s execution would have
        reached its end. At that point tt(display)'s destructor would have
        been called. However, when the destructor of a em(joinable thread) is
        called, tt(terminate) is called, forcing the program's abort.)
    ithtq(joinable)(bool joinable() const noexcept)
       (returns tt(object.get_id() != id()), where tt(object) is the
        tt(thread) object for which tt(joinable) was called.)
    ithtq(swap)(void swap(thread &other) noexcept)
       (The states of the tt(thread) object for which tt(swap) was called and
        tt(other) are swapped. Note that threads may be swapped as well, even
        when their threads of execution are currently active.)
    )

The class tt(thread) supports the move assignment operator:
    itemization(
    itt(thread &operator=(thread &&tmp) noexcept):
        If the operator's left-hand side operand (lhs) is a joinable thread,
then tt(terminate) is called. Otherwise, tt(other)'s state is assigned to the
operator's lhs and sets tt(other) to the thread's default constructed state.
    )

Since the tt(tread(Fun &&fun, Args &&...args)) constructor not only accepts
functions but also function objects as its argument, a emi(local context) may
be passed to the function object's constructor. Here is an example of a thread
to which a function object is passed which is provided with a local context:
        verbinclude(examples/functorthread.cc)
    Note the argument tt(&cout) that is passed to tt(funThread) and the
definition tt(ostream *out) parameter of the tt(funThread)'s function call
operator. Here tt(cout) cannot be used (in combination with a tt(ostream &out)
parameter, since the latter parameter is not move-constructible, whereas a
pointer em(is).


