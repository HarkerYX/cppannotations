The ti(Standard Template Library) (i(STL)) is a i(general purpose library)
consisting of i(containers),
    i(generic algorithms), i(iterators), i(function objects),
    allocators, i(adaptors) and i(data structures). The data structures used
in the algorithms are em(abstract) in the sense that the algorithms can be
used on (practically) every data type.

The algorithms can work on these i(abstract data types) due to the fact that
they are emi(template) based algorithms. In this chapter the em(construction)
of templates is not discussed (see chapter ref(TEMPLATES) for that). Rather,
this chapter focuses on the em(use) of these template algorithms.

Several parts of the standard template library have already been discussed in
the bf(C++) Annotations. In chapter ref(CONTAINERS) the abstract containers
were discussed, and in section ref(FUNOBJ) function objects were introduced.
Also, em(iterators) were mentioned at several places in this
document.

The remaining components of the STL will be covered in this and the next
chapter. Iterators, adaptors, smart pointers, multi threading and other
features of the STL will be discussed in the coming sections. Generic
algorithms are covered in the next chapter (ref(GENERIC)).

em(Allocators) take care of the memory allocation within the
STL. The default i(allocator class) suffices for most applications, and is
not further discussed in the bf(C++) Annotations.

All elements of the STL are defined in the standard namespace. Therefore, a
tt(using namespace std) or comparable directive is required unless it is
preferred to specify the required namespace explicitly. This occurs in at
least one situation: in header files no tt(using) directive should be used,
so here the tt(std::) scope specification should always be specified when
referring to elements of the STL.
