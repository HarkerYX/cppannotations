There are three ways to hi(unique_ptr: defining) define tt(unique_ptr)
objects. Each definition contains the usual tt(<type>) specifier between
angle brackets. Concrete examples are given in the coming sections, but an
overview of the various possibilities is presented here:
    itemization(
    it() The basic form initializes an tt(unique_ptr) object to point to a block
of memory allocated by the tt(new) operator:
        verb(
    unique_ptr<type> identifier (new-expression [, deleter]);
        )
    This form is discussed in section ref(UNIQUENEW).
    it() Another form initializes an tt(unique_ptr) object using em(move
semantics), either supported by the data type itself or forced using
tt(std::move):
        verb(
    // type must support move semantics or std::move(other) must be used
    unique_ptr<type> identifier(another unique_ptr for type);
        )
    This form is discussed in section ref(UNIQUEMOVE).
    it() The third form simply creates an tt(unique_ptr) object that
does not point to a particular block of memory:
        verb(
    unique_ptr<type> identifier;
        )
    This form is discussed in section ref(UNIQUEPLAIN).
    )
