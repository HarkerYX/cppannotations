In bf(C++), temporary (rvalue) values are indistinguishable from tt(const &)
types. the i(C++0x standard) adds a new reference type called an 
    emi(rvalue reference), defined as
    ti(typename &&).

The name em(rvalue) reference is derived from assignment statements, where the
variable to the left of the assignment operator is called an emi(lvalue) and
the expression to the right of the assignment operator is called an
emi(rvalue). Rvalues are often temporary values, like values returned by
functions. 

In this parlance the bf(C++) reference should be considered an 
    emi(lvalue reference) (which uses the tt(typename &) notation). In
contrast, the em(rvalue reference) uses the tt(typename &&) notation which can
be used to refer to temporaries. When the term reference is used, it refers to
both kinds of reference: lvalue reference and rvalue reference. Here is an
example:
        verb(
    int &ir = int(3);       // fails: int(3) is a temporary
    int const &ic = int(3)  // OK: immutable temporary 

    int &&irr = int(3);     // OK: rvalue reference
    ++irr;                  // OK: now the temp. value equals 4
        )

The above clearly is a rather complex way to define a variable. However, the
concept allows the implementation of em(move semantics) and em(perfect
forwarding) . 

At this point in the Annotations the concept of emi(move semantics) cannot yet
fully be discussed (but see section ref(MOVE) for a more thorough
discussusion) but it is very well possible to illustrate the underlying ideas.

Consider the situation where a function returns a tt(struct Data) containing a
pointer to dynamically allocated data. Moreover, the struct defines a member
function tt(copy(Data const &other)) that takes another tt(Data) object and
copies the other's data into the current object. The (partial) definition of
the tt(struct Data) might look like this+footnote(In this example the memory
leak that might result from using Data::copy() can be ignored):
        verb(
    struct Data
    {
        char *text;
        size_t size;
        void copy(Data const &other)
        {
            text = strdup(other.text);
            size = strlen(text);
        }
    };
        )
    Next, functions tt(makeData()) and tt(main()) are defined as follows:
        verb(
    Data makeData(char const *txt)
    {
        Data ret = {strdup(txt), strlen(txt)};
        return ret;
    }

    int main()
    {
        Data d1 = {strdup("hello"), strlen("hello")};

        Data d2;
        d2.copy(d1);                        // 1 (see text)

        Data d3;
        d3.copy(makeData("hello"));         // 2

        return 0;
    }
        )
    At tt((1) d2) appropriately receives a copy of tt(d1)'s text. But at
tt((2) d3) receives a copy of the text stored in the temporary returned by the
tt(makeData) function. As the temporary ceases to exist after the call to
tt(copy()) two releated and unpleasant consequences are observed:
        itemization(
        it() The return value is a temporary object: its only reason for
existence is to pass its data on to tt(d3). But instead tt(d3) copies the
temporary's data with clearly is somewhat overdone.
        it() The temporary tt(Data) object is lost following the call to
tt(copy()). Unfortunately, so is its dynamically allocated data: resulting in 
a memory leak.
        )
    In cases like these the em(rvalue reference) comes in handy. By
overloading the tt(copy) member with a tt(copy(Data &&other) member the
compiler is given a chance to distinguish situations (1) and (2), and to call
the original tt(copy()) member in situation (1) and to call the overloaded
tt(copy()) member in situation (2):
        verb(
    struct Data
    {
        char *text;
        size_t size;
        void copy(Data const &other)
        {
            text = strdup(other.text);
        }
        void copy(Data &&other)
        {
            text = other.text;
            other.text = 0;
        }
    };
        )
    Note that the overloaded tt(copy()) function merely moves the
tt(other.text) pointer to the current object's tt(text) pointer followed by
reassigning 0 to tt(other.text). The tt(struct Data) suddenly has become
emi(move aware) and implements em(move semantics), removing the drawbacks of
the previously shown approach:
    itemization(
    it() Instead of making a deep copy (which is required in situation (1)),
the pointer value is simply moved to its new owner;
    it() Since the tt(other.text) doesn't point to dynamically allocated
memory anymore the memory leak is prevented.
    )

No development for rvalue references for tt(*this) and initialization of class
objects by rvalues is currently forseen in tt(g++) up to version 4.4.

