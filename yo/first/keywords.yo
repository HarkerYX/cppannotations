bf(C++)'s  i(keywords) are a superset of bf(C)'s  keywords. Here is a
list of all keywords of the language:
        verb(
alignof
   and        compl  explicit              new    requires  typedef
and_eq      concept    extern              not       short   typeid
   asm        const     false           not_eq      signed typename 
          constexpr
  auto   const_cast     float          nullptr      sizeof    union
 axiom     continue       for         operator      static unsigned
bitand     decltype    friend               or static_cast    using
 bitor      default      goto            or_eq      struct  virtual 
  bool       delete        if          private      switch     void 
                       import
 break           do    inline        protected    template volatile 
  case       double       int           public        this  wchar_t 
 catch dynamic_cast      long         register       throw    while 
  char         else   mutable reinterpret_cast        true      xor
 class         enum namespace           return         try   xor_eq     
    )         
    Notes:
    itemization(
    it() The ti(nullptr) keyword is defined in the i(C++0x standard) 
(not yet available in tt(g++ 4.4)).
    it()  the emi(operator keywords): tt(and, and_eq, bitand, bitor, compl,
not, not_eq, or, or_eq, xor) and tt(xor_eq) are symbolic alternatives for,
respectively, tt(&&, &=, &, |, ~, !, !=, ||, |=, ^) and tt(^=).
    )

Keywords can only be used for their intended purpose and cannot be used as
names for other entities (e.g., variables, functions, class-names, etc.). In
addition to keywords i(identifiers starting with an underscore) are 
    i(reserved identifiers) in the sense that their use is a prerogative of
the implementor.

COMMENT(
    and       and_eq  asm     auto
    bitand    bitor   bool    break
    case      catch   char    class   compl
              const const_cast continue
    default   delete  do      double  dynamic_cast
    else      enum    explicit extern
    false     float   for     friend
    goto
    if        inline  int
    long
    mutable
    namespace new               not     not_eq
    operator  or                or_eq
    private   protected         public
    register  reinterpret_cast  return
    short     signed  sizeof  static static_cast
              struct   switch
    template  this   throw   true    try
              typedef typeid  typename
    union     unsigned    using
    virtual   void    volatile
    wchar_t   while
    xor       xor_eq
END COMMENT)
