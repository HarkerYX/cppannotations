Template hi(template template parameter)
    template parameters allow us to specify a em(template class) as a template
parameter. By specifying a template class, it is possible to add a certain
kind of behavior, called emi(policy) to an existing template class.

Consider the class tt(Storage), introduced at the beginning of this section,
and consider the allocation classes discussed in the previous section. To
specify an em(allocation policy) the class tt(Storage) starts its
definition as follows:
        verb(
    template <typename Data, template <typename> class Policy>
    class Storage ...
        )
    The second template parameter is the emi(template template parameter). It
contains the following elements:
        itemization(
        it() The keyword tt(template) starts the definition of a template
            template parameter;
        it() It is followed, between pointed brackets, a list of template
            parameters that must be specified for the template template
            parameter. These parameters em(may) be given names, but these
            names cannot be used in the subsequent template definition, and
            are therefore usually omitted. On the other hand, providing formal
            names may help the reader of the template to understand the kinds
            of templates that may be specified as template template
            parameters. 
        it() The template parameters must match, in number and type, the
            template parameters that must be specified for the policy. Default
            values cannot be specified here.
        it() Following the bracketed list the keyword ti(class) is
            provided. In this case, tt(typename) 
                hi(typename vs. class)
            cannot be used. 
        )
    Since the policy class should be an inherent part of the class under
consideration, the policy class is often deployed as a base class. So,
tt(Policy) becomes a base class of tt(Storage). Moreover, the policy should
operate on the data type to be used with the class tt(Storage), so the policy
is given that data type as well. From this we reach the following setup:
        verb(
    template <typename Data, template <typename> class Policy>
    class Storage: public Policy<Data>
        )
    This scheme allows us to use the policy's members when implementing the
class tt(Storage)'s member. 

    Now the allocation classes don't seem to offer many useful members. One of
the drawbacks of the current allocation classes is that, apart from the
extraction operator, no immediate access to the data is offered. This can
easily be repaired by providing, e.g., conversion operators. E.g., the 
class tt(NewAlloc) could be extended with the following members:
            verb(
        operator Data &()
        {
            return *d_data;
        }
        operator Data const &() const
        {
            return *d_data;
        }
        NewAlloc &operator=(Data const &data)
        {
            *d_data = data;
        }
            )
        














