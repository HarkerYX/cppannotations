A emi(policy) defines (in some contexts: prescribes) a particular kind of
behavior. In our context a hi(class: policy) em(policy class) defines a
certain part of the class interface, and it may define i(inner types),
i(member functions) and i(data members). 

In the previous section the engineer was confronted with the task to create a
class which might use a series of allocation schemes. These allocation schemes
all depend on the actual data type to be used, and so the `template' reflex
should kick in: the allocation schemes are probably template classes, applying
the appropriate allocation procedure to the data type at hand. E.g. (using
in-class implementations to save some space), the following three allocation
classes may have been defined:
    itemization(
    it() No special allocation takes place, tt(data) is used `as is':
        verb(
    template <typename Data>
    class PlainAlloc
    {
        public:
            Data *alloc(Data &data) // returns a pointer to `data' itself
            {
                return &data;
            }
    };
        )
    it() The standard tt(new) operator is used to allocate a new copy:
        verb(
    template <typename Data>
    class NewAlloc
    {
        public:
            Data *alloc(Data &data) // returns a new copy of `data'
            {
                return new(data);
            }
    };
        )
    it() The i(placement new) operator (see section ref(PLACEMENT))
        is used, requesting memory from a 
        common pool of bytes (the implementation of the member tt(request()),
        obtaining the required amount of memory is left as an exercise to the
        reader): 
        verb(
    template <typename Data>
    class PlacementAlloc
    {
        static char *s_commonPool;
        public:
            Data *alloc(Data &data) // uses the placement new operator
            {                       
                return new(request(sizeof(Data))) Data(data);
            }
    };
        )
    The above classes define em(policies) that may be selected by the user of
the class tt(Storage), introduced in the previous section. Moreover, the user
is free to design and used additional  allocation classes as well. 

    To apply the proper allocation class to the class tt(Storage) we first
state that tt(Storage) itself will be a template class, as the data type to be
used with tt(Storage) is unspecified. But in addition to tt(typename Data) the
em(allocation policy) must be specified. The allocation policy is em(not) a
i(template type parameter) and it's not a i(template non-type
parameter). Instead a new kind of template parameter is needed: a 
    emi(template template parameter).

