Scattered over the tt(std) namespace 
    hi(trait class)hi(class: trait)
    em(trait classes) are found. E.g., most bf(C++) programmers will have seen
the compiler mentioning `tt(std::char_traits<char>)' when performing an
illegal operation on tt(std::string) objects, as in tt(std::string s(1)).

    Trait classes are used to make compile-time decisions about types. Traits
classes allow the software engineer to apply the proper code to the proper
data type, be it a pointer, a reference, a value, all maybe in combination
with tt(const). Moreover, the specification of the particular type of data to
use does not have to be made by the template writer, but can be inferred from
the actual type that is specified (or implied) when the template is used.

    Trait classes allow the software engineer to develop a tt(template
<typename Type1, typename Type2, ...>) without the need to specify many
specializations covering all combinations of, e.g., values, (const) pointers,
or (const) references, which would soon result in an unmaintainable
exponential explosion of template specializations (e.g., allowing these five
different actual types for each template parameter already results in 25
combinations when two template type parameters are used: each must be covered
by a potentially different specialization)

    Having available a trait class, the actual type can be inferred compile
time, allowing the compiler to deduct whether or not the actual type is a
pointer, a pointer to a member, a const pointer, and make comparable
deductions in case the actual type is, e.g., a reference type. This in turn
allows us to write templates that define types like ti(argument_type),
ti(first_argument_type), ti(second_argument_type) and ti(result_type), which
are required by several generic algorithms (e.g., link(count_if())(COUNTIF),

    A trait class usually performs no behavior. I.e., it has no constructor
and no members that can be called. Instead, it defines a series of types and
enum values that have certain values depending on the actual type that is
passed to the trait class template.  The compiler uses specialization to
select the appropriate specialization given an actual template type parameter.

    The generic point of departure when defining a trait template is a plain
vanilla struct, defining the characteristics of a plain value type, e.g., an
tt(int).  This sets the stage for specific specializations, modifying the
characteristics for any other type that could be specified for the template.

    To make matters concrete, assume the intent is to create a trait class
tt(BasicTraits) telling us whether a type is a plain value type, a pointer
type, or a reference type (all of which may or may not be tt(const) types).

    Moreover, whatever the type that's passed, we want to be able to determine
the `plain' type (i.e., the type without any modifiers, pointers or
references), the `pointer type' and the `reference type', allowing us to
define in all cases, e.g., a reference to its basic type, even though we
passed a const pointer to that type.

    Our 

    