Now that tt(Conversion) has be defined it's easy to determine whether a type
tt(Base) is a (public) base class of a type tt(Derived). To determine
inheritance convertability of (const) pointers is examined. tt(Derived const
*) can be converted to tt(Base const *) if:
    itemization(
    it() Both types are identical;
    it() tt(Base) is a public and unambiguous base class of tt(Derived);
    it() and also, but usually not intended: if tt(Base) is void.
    )
    Preventing the latter, inheritance is determined by inspecting
tt(Conversion<Derived const *, Base const *>::exists):
        verbinsert(BASEFIRST)(templateapp/examples/conversion.h)

    If code should not consider a class to be its own base class, then the
following stricted test is possible, which adds a test for type-equality:
        verbinsert(BASESTRICT)(templateapp/examples/conversion.h)

The following example writes tt(1: 0, 2: 1, 3: 0, 4: 1, 5: 0) when run from a
tt(main()) function:
        verbinsert(INHERITANCE)(templateapp/examples/conversion.cc)
