Next the selection of a type from a typelist given its index will be
discussed. This is the inverse operation from obtaining the index of a
`searchtype', as covered by section ref(SEARCHTYPE). 

Rather than defining an tt(enum) value, the current algorithm should define a 
type equal to the type at a given index position. If the type does not exist,
the typedef can be made a synonym of tt(NullType) since tt(NullType) cannot
appear in a typelist.

The following algorithm is used (the implementation of the parts is provided
immediately following the descriptions of the algorithm's steps):
    itemization(
    it() The foundation of the algorithm is provided by a declaration of
a struct tt(TypeAt), expecting an index and a typelist.
        verb(
    template <int index, typename Typelist>
    struct TypeAt;
        )
    it() If the typelist equals tt(NullType) define the return type as
tt(NullType) as well.
        verb(
    template <int index>
    struct TypeAt<index, NullType>
    {
        typedef NullType result;
    };
        )
    it() If the search index equals 0, define the return type as the
typelist's head.
        verb(
    template <typename Head, typename Tail>
    struct TypeAt<0, TypeList<Head, Tail> >
    {
        typedef Head result;
    };
        )
    it() Otherwise, define the return type as the return type of the type at
offset index - 1 in the typelist's tail. Note the tt(typename) following
tt(typedef): it is required as the defining type's tt(result) type is a nested
type.
        verb(
    template <int index, typename Head, typename Tail>
    struct TypeAt<index, TypeList<Head, Tail> >
    {
        typedef typename TypeAt<index - 1, Tail>::result result;
    };
        )
    )
    Assuming all required headers have been included, the following example
shows how tt(ListSearch) can be used:
        verb(
    int main()
    {
        typedef TYPELIST_3(int, char, bool) list3;
        enum { test = 2 };

        std::cout << 
            (ListSearch<TypeAt<test, list3>::result, list3>::index == -1 ?
                "Illegal Index\n"
            :
                "Index represents a valid type\n");
    }
        )

