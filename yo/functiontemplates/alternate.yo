Traditional  bf(C++) requires function templates to specify their return type
or to specify the return type as a template type parameter. Consider the
following function:
        verb(
    int add(int lhs, int rhs)
    {
        return lhs + rhs;
    }
        )
 The above function may be converted to a (more generic) template function:
        verb(
    template <typename Lhs, typename Rhs>
    Lhs add(Lhs lhs, Rhs rhs)
    {
        return lhs + rhs;
    }
        )
 Unfortunately, when the template function is called as
        verb(
    add(3, 3.4)
        )
 the intended return type is probably a tt(double) rather than an
tt(int). This can be solved by adding an additional template type parameter
specifying the return type, but it requires the specification of that type:
        verb(
    add<double>(3, 3.4);
        )
 This problem can't be solved using ti(decltype) (cf. section ref(AUTO)) as
tt(lhs) and tt(rhs) aren't known to the compiler by the time tt(decltype) is
used in the following attempt to get rid of the additional type parameter:
        verb(
    template <typename Lhs, typename Rhs>
    decltype(lhs + rhs) add(Lhs lhs, Rhs rhs)
    {
        return lhs + rhs;
    }
        )

The i(C++0x) standard provides the emi(late-specified return type)
syntax that em(does) allow the use of tt(decltype) to define a function's
return type (it is primarily used with template functions but it may also be
used for non-template functions):
        verb(
    template <typename Lhs, typename Rhs>
    auto add(Lhs lhs, Rhs rhs) -> decltype(lhs + rhs)
    {
        return lhs + rhs;
    }
        )
 When this function is used in a staement like tt(cout << add(3, 3.4)) the
resulting value will be 6.4, which is most likely the intended result, rather
than 6.

The expression specified with tt(decltype) does not necessarily use the
parameters tt(lhs) and tt(rhs). In the following function definition
tt(lhs.length()) is used instead of tt(lhs) itself:
        verb(
    template <typename Class, typename Rhs>
    auto  add(Class lhs, Rhs rhs) -> decltype(lhs.length() + rhs)
    {
        return lhs.length() + rhs;
    }
        )
    Any variable visible at the time tt(decltype) is compiled can be used in
the tt(decltype) expression. However, it is currently not possible to handle
member selection through pointers to members. The following code aims at
specifying the address of a member function as tt(add)'s first argument and
then use its return value type to determine the template function's return
type:
        verb(
    std::string global;

    template <typename MEMBER, typename RHS>
    auto  add(MEMBER mem, RHS rhs) -> decltype((global.*mem)() + rhs)
    {
        return (global.*mem)() + rhs;
    }
        )
    Although the above function compiles fine, it cannot currently be used as
it results in a compiler error message like
    emi(unimplemented: mangling dotstar_expr) (generated for a statement like
tt(cout << add(&string::length, 3.4))).
