Situations exist where the compiler is unable to infer that a reference rather
than a value is passed to a template function. In the following example the
template function tt(outer) receives tt(int x) as its argument and the
compiler will dutifully infer that tt(Type) is tt(int):
        verbinsert(INT)(functiontemplates/examples/refwrapper.cc)
    Compilation will of course fail and the compiler nicely reports the
inferred type, e.g.:
    verb(
    In function 'void outer(Type) [with Type = int]': ...
    )

Unfortunately the same happens too when in the next example tt(call) is
used. The function tt(call) is a template expecting a function that takes an
argument which is then itself modified and a value to pass on to that
function. Such a function is, e.g., tt(sqrtArg) expecting a reference to a
tt(double), which is modified by calling tt(std::sqrt).
        verbinsert(DOUBLE)(functiontemplates/examples/refwrapper.cc)

Assuming tt(double value = 3) then tt(call(sqrtArg, value)) will not modify
tt(value) as the compiler infers tt(Arg) to be tt(double) and hence passes
tt(value) by value. 

To have tt(value) itself changed the compiler must be informed that tt(value)
must be passed by reference. Note that it might not be acceptable to define
tt(call)'s template argument as tt(Arg &) as em(not) changing the actual
argument might be appropriate in some situations.

The i(C++-0x standard) offers the ti(ref(arg)) and ti(cref(arg)) 
    emi(reference wrapper)em(s) that will take an argument and return it as a
reference-typed argument. To actually change tt(value) it can be passed to
tt(call) using tt(ref(value)) as shown in the following tt(main) function:
        verbinsert(MAIN)(functiontemplates/examples/refwrapper.cc)

To use a reference wrapper the header file ti(functional)
    hi(#include <functional>) must be included.
