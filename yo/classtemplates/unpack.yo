    The emi(unpack operator) is used to obtain template arguments in many
situations. No mechanism other than recursion (as shown in section
ref(DEFVARTEMP))) is available to obtain the individual types and values of a
variadic template.

    The unpack operator can also be used to define template classes that are
derived from any number of base classes. Here is how it's done:
        verb(
    template <typename... BaseClasses>
    class Combi: public BaseClasses ...         // derive from base classes
    {
        public:                                 
                                                // specify base class objects
                                                // to its constructor using
                                                // perfect forwarding
            Combi(BaseClasses && ... baseClasses)
            :
                BaseClasses(baseClasses) ...    // use base class initializers
            {}                                  // for each of the base 
    };                                          // classes
        )
    This allows us to define classes that combine the features of any number
of other classes. If the class tt(Combi) is derived of classes tt(A, B,) and
bf(C) then tt(Combi) is-a tt(A, B,) and tt(C). It should of course be given a
virtual destructor. A tt(Combi) object can be passed to functions expecting
pointers or references to any of its base class type objects. Here is an
example defining tt(Combi) as a class derived from a vector of complex
numbers, a string and a pair of ints and doubles (using uniform intializers in
a sequence matching the sequence of the types specified for the used tt(Combi)
type):
        verb(
    typedef Combi<vector<complex>>, string, pair<int, double>> MultiTypes;
    MultiTypes mt({{3.5, 4}, {-1, -1}}, "mt", {1950, 1.72});
        )
