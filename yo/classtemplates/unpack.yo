    The emi(unpack operator) can be used to obtain template arguments in
many situations. No mechanism other than recursion (as shown in the previous
section) is available to obtain the individual types or values of a variadic
template.

    The unpack operator can also be used to define a template class that is
derived from any number of base classes. Here is an example:
        verb(
    template <typename... BaseClasses>
    class ClassName: public BaseClasses ...
    {
        public:
            ClassName(BaseClasses && ... baseClasses)
            :
                BaseClasses(baseClasses) ...
            {}
    };

        // Define a class derived from a vector, a complex and a string:
    ClassName<std::vector<std::string>>, std::complex, std::string>
        object({"one", "two", "three"}, {3, 2.5}, "hello world");
        )
    In this example the unpack operator appears as the ellipses trailing
tt(BaseClasses). The class tt(ClassName) is derived from each of the types
specified when instantiating tt(ClassName) and here tt(ClassName)'s
constructor expects a reference to each base class which is used to initialize
the base classes of ClassName. The construction of tt(object) illustrates how
this may be accomplished: (uniform) intializers are used in a sequence
matching the sequence of the types specified for the used tt(ClassName) type.

    When using the unpack operator in combination with function templates it
allows the template to forward the variadic parameters. When rvalue references
are used in this case  perfect forwarding (cf. section
ref(PERFECT)) can be used. Here is an example:
        verb(
    template<typename Type>
    struct Allocator
    {
        template<typename ... Args>
        std::shared_ptr<Type> factory(Args && ... params)
        {
            return std::shared_ptr<Type>(
                            new Type(std::forward<Args>(params) ...));
        }
    }
        )
    This example has the following characteristics:
    itemization(
    it() The argument list of the member function template tt(factory) is
unpacked into tt(Type)'s constructor.
    it() The tt(std::forward<Args>(params))
syntax ensures that an  argument is forwared to tt(Type)'s constructor using
its actual type (and a matching tt(Type) constructor must be available).
    it() In addition to this (i.e., to using tt(forward)) the
unpack operator (activated by the ellipses trailing the tt(std::forward)
call) ensures that the forwarding is applied to each argument in turn.
    )
