The C++0x standard adds emi(unrestricted unions) to C++'s
capabilities. Whereas the traditional tt(union) can only contains primitive
data, unrestricted unions allow data fields of types for which a non-trivial
constructors have been defined. Such data fields commonly are of
class-types. Here is an example of a basic definition of such an unrestricted
union:
        verb(
    union Union
    {
        int u_int;
        double u_double;
        std::string u_string;
    };
        )

As a union defines different class type data fields the question becomes how
these unions can be constructed and destroyed. If a union consists of, e.g. a
tt(std::string) and a tt(double) data field the tt(string)'s destructor should
of course not be called if the union's last (or only) use referred to its
tt(double) field. Likewise, when the tt(std::string) field is being used, but
a switch is made from using the tt(std::string) to the tt(double) the
tt(std::string)'s destructor should be called before any assignment to the
tt(double) field.

These tasks are too difficult for the compiler to solve, and the compiler will
therefore em(not) implement default constructors and destructors for
unrestricted unions, leaving the implementations of the union's constructors
and destructor to the software engineer.

This implies that the program must know what the union's active field is, so
that it can take the appropriate actions at construction, assignment, and
destruction time.

Intuitively we may be tempted to define the unrestricted union as a data
member in a tt(class) defining a emi(d_tag) data member, indicating the
currently active union field, in the surrounding tt(class). Here is an example
of such an unrestricted union embedded in a surrounding class:
        verb(
    class Surround
    {
        int d_tag;
        union Union
        {
            std::ostringstream ostr;
            std::string str;
            int iValue;

            ~Union()
            {
                // ???
            }
        };
        Union d_union;
    };
        )
    Unfortunately we're confronted with a complication: the union's destructor
must have access to the tt(d_tag) field to know which of its fields must be
destroyed. Since it has no knowledge about the tt(Surround) object to which it
belongs, it cannot access the relevant tt(d_tag) member.

    It's of course also not possible to add a tag field to the union itself:
doing so would result in the tag field becoming yet another field of the
union, whose value would be undefined once another of the union's fields would
be used.

    But placing the tag field inside the union is an attractive option, as it
leaves the responsibility of what to do with the union itself. How can this be
accomplished? 

    First we define a simple class template: tt(UnionTag). The
tt(UnionTag) class template expects a tag value (an tt(int) and a type. It
defines a simple struct consisting of two data members: an tt(int) and a data
member of the specified data type:
        verb(
    template <int tg, typename Type>
    struct UnionTag
    {
        int tag;
        Type data;
        
        Tag(Type const &tp)
        :
            tag(tg),
            data(tp)
        {}
    };
        )
    The above tt(UnionTag) shows a basic implementation. More elaborate
implementations could also define, e.g., a move constructor. 

    Next we define the unrestricted union, where its data fields are defined
and tagged using tt(UnionTag)s. E.g,
        verb(
    union Union
    {
        Tag<1, double>  value;
        Tag<2, string>  str;
        Tag<3, std::ostringstream>  oss;
    };
        )
    At this point we would be able to access the various data fields. We could
do, e.g.,
        verb(
    Union union;
    union.str.data = "hello world";
        )
    Of course, the program(mer) must know that the union's tt(str) field is
active before it is correct to use it, but that has always been true when
unions were used. 

    Unrestricted unions are associated with a particular data field at
construction time. For this purpose constructors may provide the approriate
initialization values. Once a value has been initialized the initialized data
field becomes the active field. Other fields are (should be) ignored. 

The
constructors for the above unrestricted union could be implemented like this:
        verb(
    Union::Union(string const &st)
    {
        new(&str) Tag<2, string>(st);
    }

        
