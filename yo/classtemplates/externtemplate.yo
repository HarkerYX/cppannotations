In bf(C++) templates are instantiated when their address is taken or when they
are used. As described in section ref(DECLCLASSTEMP) it is possible to
forward declare a class template in order to allow the definition of a
pointer or reference to that template class or to allow it being used as a
return type.

In other situations templates are instantiated when they are being used.  If
this happens many times (i.e., in many different source files) then this may
slow down the compilation process considerably. The i(C++0x standard) allows
programmers to em(prevent) templates
    hi(template instantiation: preventing)
    hi(preventing template instantiation)
        from being instantiated. For this the ti(extern template) syntax is
introduced. The following example declares the tt(std::vector<int>) template:
        verb(
    extern template class std::vector<int>;
        )
    Having declared the class template it can be used in its translation
unit. E.g., the following function will properly compile:
        verbinclude(classtemplates/examples/extern.cc)
    Note, however:
    itemization(
    it() The declaration by itself does not make the class definition
available. The tt(vector) header file still needs to be included to make the
features of the class vector known to the compiler;
    it() The compiler em(assumes) (as it always does) that what's declared
here is implemented elsewhere. But in this case the compiler encounters an
    emi(implicit declaration): the features of the vector class that are
actually used by the above program are not individually declared but they are
declared as a group, using the ti(extern template) declaration. This not only
holds true for explicitly used members, but any hidden members (copy
constructors, move constructors, conversion operators, constructors called
during promotions, to name a few): all are assumed by the compiler
to have been instantiated elsewhere;
    it() The above source file will em(compile) but the compiler must find the
instantiations before its linker can produce a final program. To accomplish
this one or more sourcefiles may be constructed in which all the required
instantiations are eventually made available.

    In a stand-alone program one might postpone defining the required members
and wait for the linker to complain about unresolved external
references. These may then be used to create a series of instantiation
declarations which are then linked with the program to satisfy the linker. Not
a very simple task, though, as the declarations must strictly match the way
the members are declared in the class interface. An easier approach is to
define an emi(instantiation source) em(file) in which all the facilities that
are used by the program are actually instantiated in a function that is not
called by the program. By adding this instantiation function to the source
file containing tt(main) we can be sure that all required members will be
instantiated as well. Here is an example of how this may be done:
        verbinclude(classtemplates/examples/extern2.cc)
    )
