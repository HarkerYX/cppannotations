Although normally there should be an tt(operator delete) call for every call
to tt(operator new), there is a noticeable exception to that rule. It is
called the emi(placement new) hi(new: placement) operator.

In this variant of tt(operator new) the operator accepts a block of memory and
initializes it using a constructor of choice. The block of memory should of
course be large enough to contain the object, but apart from that no other
requirements exist.

The placement tt(new) operator uses the following syntax (using tt(Type) to
indicate the data type that is used):

        verb(
    Type *new(void *memory) Type(arguments);
        )
    Here, tt(memory) is block of memory of at least tt(sizeof(Type)) bytes
large (usually tt(memory) will point to an array of characters), and
tt(Type(arguments)) is any constructor of the class tt(Type).

    The placement tt(new) operator comes in handy when the memory to contain
one or more objects is already available or when its size is known
beforehand. The memory could have been statically or dynamically allocated;
when allocated dynamically the appropriate destructor must
eventually be called to destroy the objects and the block of memory. When
allocated statically the memory on which the placement tt(new) operator will
operate will eventually be returned automatically.

    The memory that is made available to the placement tt(new) operator will
normally be memory containing primitive types.

The question of how to call the destructors of objects initialized using
    hi(delete: and placement new)
the placement tt(new) operator is an interesting one:

    itemization(
    it() When one object was initialized in memory not allocated dynamically,
tt(delete) can of course not be called to free the statically allocated memory.
    it() However, when tt(delete) is called to free the memory pointed to by
the pointer returned by the dynamically allocated memory is properly returned
to the common pool.
    )
    Assuming that tt(buffer) is an array the size of a tt(std::string) the
tt(string)'s destructor is called in both situations:
        verb(
    delete   new(buffer) string("hello world");
        )
    In this case tt(delete) performs two actions:
    itemization(
    it() First, the object's destructor is called;
    it() Next, the memory occupied by the object whose destructor has just
been called is assumed to have been dynamically allocated and is returned to
the common pool.
    )
    Of course, the second step will fail when the buffer hasn't been allocated
dynamically as in the following example:
        verb(
    char buffer[sizeof(string)];
    delete new(buffer) string("hello world");
        )
    Consequently, when the placement tt(new) operator is used to initialize a
em(statically) allocated block of memory tt(delete) cannot be called. This
immediately raises the question of how to activate the destructor of the
object initialized in tt(buffer). The answer may come as a surprising: it
must be called hi(destructor: called explicitly) explicitly. Here is an
example:
        verbinclude(memory/examples/placement.cc)

    Using the placement tt(new) operator is clearly dangerous: depending on
the nature of the used buffer (dynamically allocated or statically allocated)
tt(delete) will either succeed or fail and it's the responsibility of the
software engineer to make sure that either tt(delete) is called or the
object's destructor is explicitly called.

    So far, so good. All is well as long as we're using but one object. What
about allocating an array of objects? Initialization is performed as usual.
But as with tt(delete), tt(delete[]) cannot be called when the buffer was
allocated statically. Instead, when multiple objects were initialized using
the placement tt(new) operator in combination with a statically allocated
buffer all the objects' destructors must be called explicitly, as in the
following example:
        verbinsert(memory/examples/placement2.cc)(CODE)

    The placement new operator nicely illustrates what actually happens
when an object is allocated dynamically. Using the placement new operator
we're `playing memory allocator' ourselves, see also sections
ref(OVERLOADNEW), ref(OVERLOADDELETE) and ref(NEWDELETEARRAY).
