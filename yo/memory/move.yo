Our class tt(Strings) has, among other members a data member tt(string
*d_string). Clearly, tt(Strings) should define a copy constructor, a
destructor and an overloaded assignment operator.

Now consider the following function tt(loadStrings(std::istream &in))
extracting the strings for a tt(Strings) object from tt(in). Next, the
tt(Strings) object filled by tt(loadStrings) is returned by value. The
function tt(loadStrings) returns a temporary object, which can then used to
initialize an external tt(Strings) object:
        verb(
    Strings loadStrings(std::istream &in)
    {
        Strings ret;
        // load the strings into 'ret'
        return ret;
    }
    // usage:
    Strings store(loadStrings(cin));
        )
    In this example two full copies of a tt(Strings) object are required:
    itemization(
    it() initializing tt(loadString)'s value return type from its local
tt(Strings ret) object;
    it() initializing tt(store) from tt(loadString)'s return value
    )
    We can improve the above procedure by defining a
 emi(move constructor).  Here is the declaration of the tt(Strings) class move
constructor:
        verb(
    Strings(Strings &&tmp);
        )

    Move constructors of classes using dynamic memory allocation are allowed
to assign the values of pointer data members to their own pointer data members
without requiring them to make a copy of the source's data. Next, the
temporary's pointer value is set to zero to prevent its destructor from
destroying data now owned by the just constructed object. The move constructor
has em(grabbed) or
 hi(resource: stealing) em(stolen) the data from the temporary object. This is
OK as the temporary object cannot be referred to again (as it is anonymous, it
cannot be accessed by other code) and the temporary objects will cease to
exist shortly after the constructor's call. Here is the implementation of
tt(Strings) move constructor:
        verbinclude(examples/stringsmove.cc)
