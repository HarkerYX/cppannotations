In bf(C++) before the definition of the i(C++0x standard) there were
basically two ways to assign a pointer data member of a temporary object to an
em(lvalue) object: either a copy constructor or reference counting had to be
used. The C++0x standard adds emi(move semantics) to these two, allowing the
direct transfer of a temporary's pointer data to its destination.

Assume tt(class IntArray) has a data member tt(int *d_data) (as well as
other members, e.g., a data member tt(size_t d_capacity) holding the number of
tt(int) values tt(d_data) points to). As we've seen tt(IntArray) should define
a copy constructor, a destructor and an overloaded assignment operator, due to
the fact that it defines a data member which is a pointer to data managed by
the tt(IntArray) objects themselves. So, a function
tt(loadIntArray(std::istream &in)) extracting the values of an tt(IntArray)
from tt(in) must use a temporary tt(IntArray) to store the extracted values
and the statement
        verb(
    IntArray intArray(loadIntArray(cin));
        )
    will have to call the class's copy constructor to initialize
tt(intArray). Following the copy constructor's call the temporary will have to
be destroyed. Consequently, a full copy construction is required to merely
pass over the temporary's values to the final destination object. 

Enter the emi(move constructor). The move constructor is a constructor defining
an i(rvalue reference) to an object of its own class as parameter. Move
constructors are allowed to simply copy the values of pointer data members to
the final destination (not requiring any copy at all) followed by zeroing the
just copied pointer data members accessed through the rvalue reference.

Constructing the class tt(IntArray) along these lines the following class
interface is obtained (the move constructor's implementation is shown below
the class interface; the remaining members are constructed 
    standard)hi(move operator=()):
        verbinclude(memory/examples/intarraymove.cc)

When implementing the move constructor make sure that the class's destructor
inspects its  pointer data member: if it's zero tt(d_capacity) should of
course not be used to destroy that number of objects. While this is probably 
of no concern for tt(IntArray) one could conceive of a class using, e.g., a 
tt(string **) data member and a naive destructor implementation like
        verb(
    for (string **iter = d_data + d_capacity; iter-- != d_data; )
        delete *iter;
    delete d_data;
        )
    In this case, following the move constructor's action, the for-statement
is of course invalid and the implementation could be changed into:
        verb(
    if (d_data == 0)
        return;
    // copy the implementation given above to here
        )

To ensure the use of the move constructor functions returning temporaries
should not return objects by value but objects by rvalue reference. The
function tt(loadArray) used earlier should therefore have the following
signature: 
        verb(
    IntArray &&loadIntArray(std::istream &in);
        ) 

Rvalue references are often used in combination with temporary values. The
move constructor, however, will never be used when the source (rvalue) object
is a defined (named) object. In the occasional situation where using an object
as rvalue reference is considered appropriate the standard library function
ti(std::move) (expecting as its argument a named object and returning the
object as an rvalue reference, defined, e.g., in the ti(utility) header file)
should be used. E.g.,
        verb(
    Object &&mover(Object tmp)
    {
        // code to, e.g., manipulate tmp

        return std::move(tmp);  // can't directly return tmp
    }                           // as it's a named object
        )
    The tt(std::move) function performs no magic. Here is its implementation,
using functionality offered by tt(type_traits) (cf. section ref(TRAITSCPPX)):
        verb(
    template <class T>
    typename std::remove_reference<T>::type &&move(T &&a)
    {
        return a;
    }
        )
    The tt(std::move) function should be used when implementing the move
constructor to move the information in base classes or composed objects to
their new destination object. E.g. (only showing the move
constructor/operator=): 
        verb(
    class Derived: public Base
    {
        std::string d_name;

        public:
            Derived(Derived&& tmp)    // move constructor
            : 
                Base(std::move(tmp)), 
                d_name(std::move(tmp.d_name)) 
            {}

            Derived &operator=(Derived &&tmp);
    };
        )
    The implementation of the em(move operator=) is left as an exercise to
the reader. 

    Classes not using composition, inheritance or pointer members pointing to
memory owned by its objects do not benefit from defining move members. 
Their trivial copy constructors and overloaded assignment operators can be
used instead.
