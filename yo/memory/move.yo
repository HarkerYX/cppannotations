In bf(C++) before the definition of the i(C++-0x standard) there were
basically two ways to assign a pointer data member of a temporary object to an
em(lvalue) object: either a copy constructor or reference counting had to be
used. The C++-0x standard adds emi(move semantics) to these two, allowing the
direct transfer of a temporary's pointer data to its destination.

Assume tt(class IntArray) has a data member tt(int *d_data) (as well as
other members, e.g., a data member tt(size_t d_capacity) holding the number of
tt(int) values tt(d_data) points to). As we've seen tt(IntArray) should define
a copy constructor, a destructor and an overloaded assignment operator, due to
the fact that it defines a data member which is a pointer to data managed by
the tt(IntArray) objects themselves. So, a function
tt(loadIntArray(std::istream &in)) extracting the values of an tt(IntArray)
from tt(in) must use a temporary tt(IntArray) to store the extracted values
and the statement
        verb(
    IntArray intArray(loadIntArray(cin));
        )
    will have to call the class's copy constructor to initialize
tt(intArray). Following the copy constructor's call the temporary will have to
be destroyed. Consequently, a full copy construction is required to merely
pass over the temporary's values to the final destination object. 

Enter the emi(move constructor). The move constructor is a constructor defining
an i(rvalue reference) to an object of its own class as parameter. Move
constructors are allowed to simply copy the values of pointer data members to
the final destination (not requiring any copy at all) followed by zeroing the
just copied pointer data members accessed through the rvalue reference.

Constructing the class tt(IntArray) along these lines the following class
interface is obtained (the move constructor's implementation is shown below
the class interface; the remaining members are constructed 
    standard)hi(move operator=()):
        verbinclude(memory/examples/intarraymove.cc)

When implementing the move constructor make sure that the class's destructor
inspects its  pointer data member: if it's zero tt(d_capacity) should of
course not be used to destroy that number of objects. While this is probably 
of no concern for tt(IntArray) one could conceive of a class using, e.g., a 
tt(string **) data member and a naive destructor implementation like
        verb(
    for (string **iter = d_data + d_capacity; iter-- != d_data; )
        delete *iter;
    delete d_data;
        )
    In this case, following the move constructor's action, the for-statement
is of course invalid and the implementation could be changed into:
        verb(
    if (d_data == 0)
        return;
    // copy the implementation given above to here
        )

To ensure the use of the move constructor functions returning temporaries
should not return objects by value but objects by rvalue reference. The
function tt(loadArray) used earlier should therefore have the following
signature: 
        verb(
    IntArray &&loadIntArray(std::istream &in);
        ) 

Rvalue references are often used in combination with temporary values. The
move constructor, however, will never be used when the source (rvalue) object
is a defined (named) object. In the occasional situation where using an object
as rvalue reference is considered appropriate the standard library function
ti(std::move) (expecting as its argument a named object and returning the
object as an rvalue reference, defined, e.g., in the ti(utility) header file)
should be used. E.g.,
        verb(
    Object &&mover(Object tmp)
    {
        // code to, e.g., manipulate tmp

        return std::move(tmp);  // can't directly return tmp
    }                           // as it's a named object
        )
    The tt(std::move) function performs no magic. Here is its implementation,
using functionality offered by tt(type_traits) (cf. section ref(TRAITSCPPX)):
        verb(
    template <class T>
    typename std::remove_reference<T>::type &&move(T &&a)
    {
        return a;
    }
        )
    The tt(std::move) function should be used when implementing the move
constructor to move the information in base classes or composed objects to
their new destination object. E.g. (only showing the move
constructor/operator=): 
        verb(
    class Derived: public Base
    {
        std::string d_name;

        public:
            Derived(Derived&& tmp)    // move constructor
            : 
                Base(std::move(tmp)), 
                d_name(std::move(tmp.d_name)) 
            {}

            Derived &operator=(Derived &&tmp);
    };
        )
    The implementation of the em(move operator=) is left as an exercise to
the reader. 

    Classes not using composition, inheritance or pointer members pointing to
memory owned by its objects do not benefit from defining move members. 
Their trivial copy constructors and overloaded assignment operators can be
used instead.



Movable but Non-Copyable Types
==============================

Some types are not amenable to copy semantics but can still be made
movable. For example:

    * fstream
    * unique_ptr (non-shared, non-copyable ownership)
    * A type representing a thread of execution

By making such types movable (though still non-copyable) their utility is
tremendously increased. Movable but non-copyable types can be returned by
value from factory functions:

ifstream find_and_open_data_file(/* ... */);
...
ifstream data_file = find_and_open_data_file(/* ... */);  // No copies!

In the above example, the underlying file handle is passed from object to
object, as long as the source ifstream is an rvalue. At all times, there is
still only one underlying file handle, and only one ifstream owns it at a
time.

Movable but non-copyable types can also safely be put into standard
containers. If the container needs to "copy" an element internally
(e.g. vector reallocation) it will move the element instead of copying it.

vector<unique_ptr<base>> v1, v2;
v1.push_back(unique_ptr(new derived()));  // ok, moving, not copying
...
v2 = v1;             // Compile time error.  This is not a copyable type.
v2 = move(v1);       // Move ok.  Ownership of pointers transferred to v2.

Many standard algorithms benefit from moving elements of the sequence as
opposed to copying them. This not only provides better performance (like the
improved std::swap implementation described above), but also allows these
algorithms to operate on movable but non-copyable types. For example the
following code sorts a vector<unique_ptr<T>> based on comparing the pointed-to
types:

struct indirect_less
{
    template <class T>
    bool operator()(const T& x, const T& y)
        {return *x < *y;}
};
...
std::vector<std::unique_ptr<A>> v;
...
std::sort(v.begin(), v.end(), indirect_less());

As sort moves the unique_ptr's around, it will use swap (which no longer
requires Copyability) or move construction / move assignment. Thus during the
entire algorithm, the invariant that each item is owned and referenced by one
and only one smart pointer is maintained. If the algorithm were to attempt a
copy (say, by programming mistake) a compile time error would result.  

NOT yet in g++:     
    Rvalue references for *this     N2439   No
    Initialization of class objects by rvalues  N1610   No
