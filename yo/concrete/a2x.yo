    The standard bf(C) library offers conversion functions like ti(atoi()),
tt(atol()), and other functions, which can be used to convert ti(ASCII-Z)
strings to numerical values. In bf(C++), these functions are still available,
but a more em(type safe) way to convert text to other types  is by using
objects of the class tt(std::istringsteam).

Using the tt(std::istringstream) class instead of the bf(C) standard
conversion functions may have the advantage of type-safety, but it also
appears to be a rather cumbersome alternative. After all, we will have to
construct and initialize a tt(std::istringstream) object first, before we're
actually able to extract a value of some type from it. This requires us to use
a variable. Then, if the extracted value is actually only needed to
initialize some function-parameter, one might wonder whether the additional
variable and the tt(istringstream) construction can somehow be avoided.

In this section we'll develop a class (ti(A2x)) preventing all the
disadvantages of the standard bf(C) library functions, without requiring the
cumbersome definitions of tt(std::istringstream) objects over and over
again. The class is called tt(A2x) for
    `i(ascii to anything)'.

    tt(A2x) objects can be used to obtain a value for any type extractable
from tt(std::istream) objects given its textual representation. Since tt(A2x)
represents the object-variant of the bf(C) functions, it is not only type-safe
but em(also) extensible. Consequently, their use is greatly preferred over the
standard bf(C) functions. Here are its characteristics:
    itemization(
    it()  tt(A2x) is derived from tt(std::istringstream), so all members
of the class tt(std::istringstream) are available. Thus, extractions of values
of variables can always be performed effortlessly. Here's the class's
interface:
        verbinsert(CLASS)(concrete/examples/a2x.h)
    it() tt(A2x) has a default constructor and a constructor expecting a
tt(std::string) argument. The latter constructor may be used to initialize
tt(A2x) objects with text to be converted (e.g., a line of text obtained from
reading a configuration file):
        verbinsert(CONS)(concrete/examples/a2x.h)
    it() tt(A2x)'s real strength comes from its tt(operator Type()) conversion
member template. As it is a member template, it will automatically adapt
itself to the type of the variable that should be given a value, obtained by
converting the text stored inside the tt(A2x) object to the variable's
type. When the extraction fails, tt(A2x)'s inherited tt(good()) member will
return tt(false):
        verbinsert(TYPE)(concrete/examples/a2x.h)
    it() Occasionally, the compiler may not be able to determine which type to
convert to. In that case, an em(explicit template type) can be used:
        verb(
            A2x.operator int<int>();
            // or just:
            A2x.operator int();
        )
        Since neither syntax looks attractive, the member template
tt(to()) was provided as well, allowing constructions like:
            centt(A2x.to(int());)
        Here is its implementation:
            verbinsert(TO)(concrete/examples/a2x.h)
    it() Once an tt(A2x) object is available, it may be reinitialized using
its tt(operator=()) member:
            verbinclude(concrete/examples/a2xis.cc)
    )

    Here are some examples of its use:
        verb(
    int x = A2x("12");          // initialize int x from a string "12"
    A2x a2x("12.50");           // explicitly create an A2x object

    double d;
    d = a2x;                    // assign a variable using an A2x object

    a2x = "err";
    d = a2x;                    // d is 0: the conversion failed,
                                // and a2x.good() == false

    a2x = " a";                 // reassign a2x to new text
    char c = a2x;               // c now 'a': internally operator>>() is used
                                // so initial blanks are skipped.

    extern expectsInt(int x);   // initialize a parameter using an
    expectsInt(A2x("1200"));    // anonymous A2x object

    d = A2x("12.45").to(int()); // d is 12, not 12.45
        )
    Apart from a class tt(A2x) a complementary class (ti(X2a)) can easily be
constructed as well. The construction of tt(X2a) is left as an exercise to
the reader.
