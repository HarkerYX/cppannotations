In Bisonc++'s grammar specification tt(%stype) will of course be
tt(Semantic). A simple grammar is defined for this illustrative example. The
grammar expects input according to the following rule:
        verb(
    rule:
        IDENTIFIER '(' IDENTIFIER ')' ';'
    |
        IDENTIFIER '=' INT ';'
    ;
        )

The rule's actions simply echo the received identifiers and tt(int) values to
tt(cout). Here is an example of a decorated production rule:
        verb(
    IDENTIFIER '=' INT ';'
    {
          cout << $1 << " " << $3 << endl;
    }
        )

Alternative actions could easily be defined, e.g., using the
tt(Base::downcast()) member:
        verb(
    IDENTIFIER '=' INT ';'
    {
        int value = $3.downcast<Int>().value();
    }
        )

Bisonc++'s parser stores em(all) semantic values on its semantic values stack
(irrespective of the number of tokens that were defined in a particular
production rule). At any time em(all) semantic values associated with
previously recognized tokens are available in an action block. Once the
semantic value stack is reduced, the tt(Semantic) class takes care of the
proper destruction of the objects pointed to by the tt(Semantic) data
member tt(d_bp).

The scanner must of course be able to access the parser's data member
representing the most recent semantic value. This data member is available as
the parser's data member tt(d_lval__), which can be offered to the scanner
object at its construction time. E.g., with a scanner expecting an 
    tt(STYPE__ &) the parser's constructor could simply be defined as:
        verb(
    inline Parser::Parser()
    :
        d_scanner(d_val__)
    {}
        )


