    The tt(monitor) program uses a tt(Monitor) object to do most of the
work. The class has only one public constructor and one public member,
tt(run()), to perform its tasks. Therefore, all other member functions
described below should be declared in the class's tt(private) section.

    tt(Monitor) defines the tt(private enum Commands), symbolically listing
the various commands its input language supports, as well as several data
members, among which a tt(Selector) object and a tt(map) using child order
numbers as its keys, and pointer to tt(Child) objects (see section ref(CHILD))
as its values. Furthermore, tt(Monitor) has a static array member
tt(s_handler[]), storing pointers to member functions handling user commands.

    A destructor should have been implemented too, but its implementation is
left as an exercise to the reader. Before the class interface can be processed
by the compiler, it must have seen tt(select.h) and tt(child.h). Here is the
class header, including its private data section:
        verbinsert(CLASS)(concrete/examples/monitor/monitor.h)

    Since there's only one non-class type data member, the class's constructor
is very short and can be implemented inline:
        verbinsert(CONS)(concrete/examples/monitor/monitor.h)

    The core of tt(Monitor)'s activities are performed by tt(run()). It
performs the following tasks:
    itemization(
    it() To prevent emi(zombie)em(s), it must be able to catch its children's
termination signals. Termination signals are caught by the member
tt(waitForChild()). It is installed by tt(run()), and it will wait for the
child's completion. Once the child is completed, it will re-install itself so
that the next termination signal may also be caught. Here is
tt(waitForChild()):
        verbinsert(WAIT)(concrete/examples/monitor/monitor.cc)
    it() Initially, the tt(Monitor) object will listen only to its standard
input: the set of input file descriptors to which tt(d_selector) will listen
is initialized to tt(STDIN_FILENO).
    it() Then, in a loop  tt(d_selector)'s tt(wait()) function is called.
If input on tt(cin) is available, it is processed by tt(processInput()).
Otherwise, the input has arived from a child process. Information sent by
children is processed by tt(processChild()).
    )
    Here is tt(run())'s implementation:
        verbinclude(concrete/examples/monitor/run.cc)

    The member function tt(processInput()) reads the commands entered by the
user via the program's standard input stream. The member itself is rather
simple: it calls tt(next()) to obtain the next command entered by the user,
and then calls the corresponding function via the corresponding element of the
tt(s_handler[]) array. This array and the members tt(processInput()) and
tt(next()) were defined as follows:
        verbinsert(HANDLER)(concrete/examples/monitor/data.cc)
        verbinsert(INPUT)(concrete/examples/monitor/processinput.cc)
        verbinsert(NEXT)(concrete/examples/monitor/processinput.cc)

    All other input sensed by tt(d_select) has been created by child
processes. Because tt(d_select)'s tt(readFd()) member returns the
corresponding input file descriptor, this descriptor can be passed to
tt(processChild()). Then, using a ti(ifdstreambuf) (see section ref(IFDBUF)),
its information is read from an input stream. The emi(communication protocol)
used here is rather basic: To every line of input sent to a child, the child
sends exactly one line of text in return. Consequently, tt(processChild())
just has to read one line of text:
        verbinsert(CHILD)(concrete/examples/monitor/processchild.cc)
    Please note the construction tt(d_child[fd]->pid()) used in the above
source. tt(Monitor) defines the data member tt(map<int, Child *> d_child).
This map contains the child's order number as its key, and a pointer to
the tt(Child) object as its value. A pointer is used here, rather than a
tt(Child) object, since we do want to use the facilities offered by the map,
but don't want to copy a tt(Child) object.

    The implication of using pointers as tt(map)-values is of course that the
responsibility to destruct the tt(Child) object once it becomes superfluous
now lies with the programmer, and not any more with the run-time support
system.

    Now that tt(run())'s implementation has been covered, we'll concentrate on
the various commands users might enter:
    itemization(
    it() When the tt(start) command is issued, a new child process is started.
A new element is added to tt(d_child) by the member tt(createNewChild()).
Next, the tt(Child) object should start its activities, but the tt(Monitor)
object can not wait here for the child process to complete its activities, as
there is no well-defined endpoint in the near future, and the user will
probably want to enter more commands. Therefore, the tt(Child) process
will run as a emi(daemon): its parent process will terminate immediately, and
its own child process will continue in the background. Consequently,
tt(createNewChild()) calls the child's tt(fork()) member. Although it is
the child's tt(fork()) function that is called, it is still the monitor
program wherein tt(fork()) is called. So, the em(monitor) program is
duplicated by tt(fork()). Execution then continues:
    itemization(
    it() At the tt(Child)'s tt(parentProcess()) in its parent process;
    it() At the tt(Child)'s tt(childProcess()) in its child process
    )
    As the tt(Child)'s tt(parentProcess()) is an empty function, returning
immediately, the tt(Child)'s parent process effectively continues immediately
below tt(createNewChild())'s tt(cp->fork()) statement.  As the child process
never returns (see section ref(CHILD)), the code below tt(cp->fork()) is never
executed by the tt(Child)'s child process. This is exactly as it should be.

    In the parent process, tt(createNewChild())'s remaining code simply
adds the file descriptor that's available for reading information from the
child to the set of input file descriptors monitored by tt(d_select), and
uses tt(d_child) to  establish the association between that
file descriptor and the  tt(Child) object's address:
        verbinsert(CHILD)(concrete/examples/monitor/createnewchild.cc)
    it() Direct communication with the child is required for the tt(stop <nr>)
and tt(<nr> text) commands. The former command terminates child process
tt(<nr>), by calling tt(stopChild()). This function locates the child process
having the order number using an anonymous object of the class tt(Find),
nested inside tt(Monitor). The class tt(Find) simply compares the
provided tt(nr) with the children's order number returned by their tt(nr())
members:
        verbinsert(FIND)(concrete/examples/monitor/monitor.h)
    If the child process having order number tt(nr) was found, its file
descriptor is removed from tt(d_selector)'s set of input file
descriptors. Then the child process itself is terminated by the static member
tt(killChild()). The member tt(killChild()) is declared as a em(static) member
function, as it is used as function argument of the tt(for_each()) generic
algorithm by tt(erase()) (see below). Here is tt(killChild())'s
implementation:
        verbinsert(KILL)(concrete/examples/monitor/monitor.cc)
    Having terminated the specified child process, the corresponding tt(Child)
object is destroyed and its pointer is removed from tt(d_child):
        verbinsert(STOP)(concrete/examples/monitor/stopchild.cc)
    it() The command tt(<nr> text>) will send tt(text) to child process
tt(nr), using the member function tt(sendChild()). This function too, will
use a tt(Find) object to locate the process having order number tt(nr), and
will then simply insert the text into the writing end of a pipe connected to
the indicated child process:
        verbinsert(SEND)(concrete/examples/monitor/sendchild.cc)
    it() When users enter tt(exit) the member tt(exiting()) is called.
It terminates all child processes, by visiting
all elements of tt(d_child), using the ti(for_each()) generic
algorithm (see section ref(FOREACH)). The program is subsequently terminated:
        verbinsert(EXIT)(concrete/examples/monitor/monitor.cc)
    )
    Finally, the program's tt(main()) function is simply:
        verbinclude(concrete/examples/monitor/main.cc)
