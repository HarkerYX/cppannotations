Below we see two class templates. tt(Base) is used as a base class of
tt(Derived):
        verbinclude(advancedtemplates/examples/basename1.cc)
    This example won't compile, and the compiler tells us something like:
        hi(no arguments depending on a template parameter)
        verb(
    error: there are no arguments to 'member' that depend on a template
           parameter, so a declaration of 'member' must be available
        )
    This error causes some confusion as ordinary (non-template) base classes
readily make their public and protected members available to classes that are
derived from them. This is no different for class templates, but only if the
compiler can figure out what we mean. In the above example the compiler
em(can't) as it doesn't know for what type tt(T) the member function
tt(member) must be initialized when called from tt(Derived<T>::Derived).

    To appreciate why this is true, consider the situation where we have
defined a specialization:
        verb(
    template <>
    Base<int>::member()
    {
        std::cout << "This is the int-specialization\n";
    }
        )
    Since the compiler does not know whether a specialization of tt(member)
will be in effect when tt(Derived<SomeType>::Derived) is called, it can't
decide (when compiling tt(Derived<T>::Derived) for what type to instantiate
tt(member). It can't decide this when compiling tt(Derived<T>::Derived) as
tt(member)'s call in tt(Derived::Derived) doesn't require a template type
parameter. 

    In cases like these, where no template type parameter is available to
determine which type to use, the compiler must be told that it should postpone
its decision about the template type parameter to use (and therefore about the
particular (here: tt(member)) function to call)
    hi(template members: without template type parameters) 
until instantiation time. 

    This may be implemented in two ways: either by using tt(this) or by
explicitly mentioning the base class, instantiated for the derived class's
template type(s). In the following tt(main) function both forms are
illustrated. Note that with the tt(int) template type the tt(int)
specialization is used.
        verbinclude(advancedtemplates/examples/basename2.cc)
