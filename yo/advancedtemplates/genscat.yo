As an illustration of template meta programming concepts the template class
ti(GenScat) will be developed now. The class template tt(GenScat) em(creates)
a new class from a template template parameter tt(Policy) defining the data
storage policy and a series of (at least one) types from which tt(GenScat) is
eventually derived. It does so by passing its template parameters to its base
class tt(GenScatter) that in turn will create the required class inheritance
tree. Here is tt(GenScat)'s definition:
    verbinsert(GENSCAT)(advancedtemplates/examples/genscatter.h)

There is a flaw in this plan.  If the tt(TypeList) contains two types like
tt(int) and tt(double) and the policy class is tt(vector), then the final
tt(GenScatter) class will inherit from tt(vector<int>) and
tt(vector<double>). So far, so good.

But the above scheme fails if the tt(TypeList) contains identical types, like
two tt(int) type specifications.  In that case the tt(GenScatter) class would
inherit from em(two) tt(vector<int>) classes, making it impossible to
distinguish among their members (actually, it isn't possible to derive a class
from two identical base classes and this by itself is of course an undesirable
result for tt(GenScatter)). Regarding this, Alexandrescu (2001)
    hi(Alexandrescu, A.) writes (p.67):
    quote( 
   em(There is one major source of annoyance...: you cannot use it when you
    have duplicate types in your tt(TypeList).nl()
   .... There is no easy way to solve the ambiguity, [as the eventually
    derived class/FBB] ends up inheriting [the same base class/FBB] twice.)
   )
    But there is a way around the problem of duplicate base class types. If
instead of inheriting from the plain base classes these base classes are first
wrapped in unique classes, then these unique classes can be used to access the
base classes using principles of inheritance. As the wrapper classes are
nothing but wrappers they inherit (and thus: offer) the functionality of their
base classes.

The problem thus shifts from handling duplicated types to finding and using an
appropriate wrapper class. Such a wrapper class can be designed after the
prviously introduced class link(IntType)(INTTYPE).  The wrapper we're looking
for should combine class derivation with the uniqueness offered by
tt(IntType).

The class tt(Wrap) is designed to combine these two desirable characteristics.
It has two template parameters: one non-type parameter tt(idx) and one type
parameter. By ensuring that each tt(Wrap) definition uses a unique tt(idx)
value unique class types are created. These unique class types are then used
as base classes of a derived class tt(GenScatter) (that itself becomes the
base class of our class tt(GenScat):
    verbinsert(WRAPPER)(advancedtemplates/examples/genscatter.h)
    Using tt(Wrap) it's easy to distinguish among, e.g., two tt(vector<int>)
classes: tt(Wrap<1, vector<int>>) refers to the first tt(vector<int>),
tt(Wrap<2, vector<int>>) refers to the second vector.
    
    Uniqueness of the various tt(Wrap) values is assured by the class
template tt(GenScatter). tt(GenScatter) becomes tt(GenScat)'s base class
and it will do all the work. 
