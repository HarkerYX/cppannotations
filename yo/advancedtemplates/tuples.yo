The i(C++-0x standard) offers a emi(generalized pair) container: the
emi(tuple), which is covered in this section. Whereas tt(std::pair) containers
have limited functionality and only two members, tuples have slightly more
functionality and may consist of a unlimited number of different data
types. In that respect a tuple can be thought of a the `template's answer to
bf(C)'s struct'.

A tuple's generic definition uses a variadic template notation:
        verb(
    template <class ...Types> class tuple;
        )
Here is an example of its actual definition and use:
        verb(
    typedef std::tuple<int, double &, std::string, char const *> tuple_idsc;
    
    double pi = 3.14;
    tuple_idsc idsc(59, pi, "hello", "fixed");
    
    // access a field:
    std::get<2>(idsc) = "hello world";
        ) 
    The template argument to the tt(std::)ti(get<idx>) function template is an
index on the ordered set of template types defined for the tuple, with 0
returning the value of its first type.
        
    Tuples may be constructed without specifying initial values. For primitive
types 0 will be used, for class types their default constructors. However,
note that the construction may succeed but its use may fail. Consider:
        verb(
    tuple<int &> empty;
    cout << get<0>(empty);
        )
    The tuple tt(empty) cannot be used as its tt(int &) field is an undefined
reference. tt(Empty)'s construction will succeed, though. 

    Tuples may be assigned to each other if their types are identical; if
appropriate copy constructors are defined; if a right-hand type can be
converted to its matching left-hand type; or if the left-hand type can be
constructed from the matching right-hand type. Furthermore, tuples (matching
in number and (convertible) types) can be compared using relational operators.

    Finally the following static elements are defined for tuple types
(using i(compile-time) initialization):
    itemization(
    it() tt(std::)ti(tuple_size<Tuple>::value) returns the number of types
defined for the tuple type tt(Tuple), e.g. the following statement displays 4:
        verb(
    cout << tuple_size<tuple_idsc>::value << endl;
        )
    it() tt(std::)ti(tuple_element<idx, Typle>::type)
        returns the type of element tt(idx) of tt(Tuple). E.g., the following
defines a tt(string) variable:
            verb(
    tuple_element<2, tuple_idsc>::type text;
            )
    )


