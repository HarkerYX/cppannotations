


The rvalue reference can also be used to achieve 

        ** perfect forwarding **

a heretofore unsolved problem in C++. From a casual programmer's perspective,
what we get from rvalue references is more general and better performing
libraries.  



To variadic templates:
======================
Due to the nature of the wording of rvalue references, and to some
modification to the wording for lvalue references (regular references), rvalue
references allow developers to provide perfect function forwarding. When
combined with variadic templates, this ability allows for function templates
that can perfectly forward arguments to another function that takes those
particular arguments. This is most useful for forwarding constructor
parameters, to create factory functions that will automatically call the
correct constructor for those particular arguments.





Perfect Forwarding

Consider writing a generic factory function that returns a std::shared_ptr for
a newly constructed generic type. Factory functions such as this are valuable
for encapsulating and localizing the allocation of resources. Obviously, the
factory function must accept exactly the same sets of arguments as the
constructors of the type of objects constructed. Today this might be coded as:

    template <class T>
    std::shared_ptr<T>
    factory()   // no argument version
    {
        return std::shared_ptr<T>(new T);
    }
    
    template <class T, class A1>
    std::shared_ptr<T>
    factory(const A1& a1)   // one argument version
    {
        return std::shared_ptr<T>(new T(a1));
    }
    
    // all the other versions

In the interest of brevity, we will focus on just the one-parameter
version. For example:

std::shared_ptr<A> p = factory<A>(5);

Question: What if T's constructor takes a parameter by non-const reference?

In that case, we get a compile-time error as the const-qualifed argument of
the factory function will not bind to the non-const parameter of T's
constructor.

To solve that problem, we could use non-const parameters in our factory
functions:

template <class T, class A1>
std::shared_ptr<T>
factory(A1& a1)
{
    return std::shared_ptr<T>(new T(a1));
}

This is much better. If a const-qualified type is passed to the factory, the
const will be deduced into the template parameter (A1 for example) and then
properly forwarded to T's constructor. Similarly, if a non-const argument is
given to factory, it will be correctly forwarded to T's constructor as a
non-const. Indeed, this is precisely how forwarding applications are coded
today (e.g. std::bind).

However, consider:

std::shared_ptr<A> p = factory<A>(5);   // error
A* q = new A(5);                        // ok

This example worked with our first version of factory, but now it's broken:
The "5" causes the factory template argument to be deduced as int& and
subsequently will not bind to the rvalue "5". Neither solution so far is
right. Each breaks reasonable and common code.

Question: What about overloading on every combination of AI& and const AI&?

This would allow us to handle all examples, but at a cost of an exponential
explosion: For our two-parameter case, this would require 4 overloads. For a
three-parameter factory we would need 8 additional overloads. For a
four-parameter factory we would need 16, and so on. This is not a scalable
solution.

Rvalue references offer a simple, scalable solution to this problem:

template <class T, class A1>
std::shared_ptr<T>
factory(A1&& a1)
{
    return std::shared_ptr<T>(new T(std::forward<A1>(a1)));
}

Now rvalue arguments can bind to the factory parameters. If the argument is
const, that fact gets deduced into the factory template parameter type.

Question: What is that forward function in our solution?

Like move, forward is a simple standard library function used to express our
intent directly and explicitly, rather than through potentially cryptic uses
of references. We want to forward the argument a1, so we simply say so.

Here, forward preserves the lvalue/rvalue-ness of the argument that was passed
to factory. If an rvalue is passed to factory, then an rvalue will be passed
to T's constructor with the help of the forward function. Similarly, if an
lvalue is passed to factory, it is forwarded to T's constructor as an lvalue.

The definition of forward looks like this:

template <class T>
struct identity
{
    typedef T type;
};

template <class T>
T&& forward(typename identity<T>::type&& a)
{
    return a;
}
