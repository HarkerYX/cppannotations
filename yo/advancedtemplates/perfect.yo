Rvalue references, implemented since the i(C++-0x standard) can also be used
to achieve emi(perfect forwarding), which was not available in bf(C++) before
the advent of the C++-0x standard. In combination with variadic templates 
rvalue references allows function templates to forward arguments to other
functions accepting such arguments. Especially in combination with
constructors accepting such arguments it allows us to create 
    i(factory functions) that can automatically call the correct constructor
matching the provided arguments.

    Factory functions in general are useful tools to encapsulate and localize
the allocation of resources. However, in order to pass the factory function's
arguments to a constructor the correct series of arguments must be provided to
the factory function. I.e., the series of arguments matching the arguments
expected by the constructor.

    Consider how a factory function might be constructed creating a series of
values of a certain type. The traditional way to do this


    template <class T>
    std::shared_ptr<T>
    factory()   // no argument version
    {
        return std::shared_ptr<T>(new T);
    }
    
    template <class T, class A1>
    std::shared_ptr<T>
    factory(const A1& a1)   // one argument version
    {
        return std::shared_ptr<T>(new T(a1));
    }
    
    // all the other versions

In the interest of brevity, we will focus on just the one-parameter
version. For example:

std::shared_ptr<A> p = factory<A>(5);

Question: What if T's constructor takes a parameter by non-const reference?

In that case, we get a compile-time error as the const-qualifed argument of
the factory function will not bind to the non-const parameter of T's
constructor.

To solve that problem, we could use non-const parameters in our factory
functions:

template <class T, class A1>
std::shared_ptr<T>
factory(A1& a1)
{
    return std::shared_ptr<T>(new T(a1));
}

This is much better. If a const-qualified type is passed to the factory, the
const will be deduced into the template parameter (A1 for example) and then
properly forwarded to T's constructor. Similarly, if a non-const argument is
given to factory, it will be correctly forwarded to T's constructor as a
non-const. Indeed, this is precisely how forwarding applications are coded
today (e.g. std::bind).

However, consider:

std::shared_ptr<A> p = factory<A>(5);   // error
A* q = new A(5);                        // ok

This example worked with our first version of factory, but now it's broken:
The "5" causes the factory template argument to be deduced as int& and
subsequently will not bind to the rvalue "5". Neither solution so far is
right. Each breaks reasonable and common code.

Question: What about overloading on every combination of AI& and const AI&?

This would allow us to handle all examples, but at a cost of an exponential
explosion: For our two-parameter case, this would require 4 overloads. For a
three-parameter factory we would need 8 additional overloads. For a
four-parameter factory we would need 16, and so on. This is not a scalable
solution.



Rvalue references offer a simple, scalable solution to this problem:

template <class T, class A1>
std::shared_ptr<T>
factory(A1&& a1)
{
    return std::shared_ptr<T>(new T(std::forward<A1>(a1)));
}

Now rvalue arguments can bind to the factory parameters. If the argument is
const, that fact gets deduced into the factory template parameter type.

Question: What is that forward function in our solution?

Like move, forward is a simple standard library function used to express our
intent directly and explicitly, rather than through potentially cryptic uses
of references. We want to forward the argument a1, so we simply say so.

Here, forward preserves the lvalue/rvalue-ness of the argument that was passed
to factory. If an rvalue is passed to factory, then an rvalue will be passed
to T's constructor with the help of the forward function. Similarly, if an
lvalue is passed to factory, it is forwarded to T's constructor as an lvalue.

The definition of forward looks like this:

template <class T>
struct identity
{
    typedef T type;
};

template <class T>
T&& forward(typename identity<T>::type&& a)
{
    return a;
}

template <class T, class A1>
std::shared_ptr<T>
factory(A1&& a1)
{
    return std::shared_ptr<T>( new T( forward<A1>(a1) )  );
}





