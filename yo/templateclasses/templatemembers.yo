    Our previous attempt to define a template non-type parameter which is
initialized by the compiler to the number of elements of an array failed
because the template's parameters are not implicitly deduced when a
constructor is called, but they are explicitly specified, when an object of
the template class is defined. As the parameters are specified just before the
template's constructor is called, there's nothing to deduce anymore, and the
compiler will simply use the explicitly specified template arguments.

    On the other hand, when template em(functions) are used, the actual
template parameters are deduced from the arguments used when calling the
function. This opens an approach route to the solution of our problem. If the
constructor itself is made into a member which itself is a template function
(containing a i(template announcement) of its own), then the compiler
will be able to deduce the non-type parameter's value, without us having to
specify it explicitly as a template class non-type parameter.

    Member functions (or classes) of template classes which themselves are
templates are called em(member templates).
        hi(member template)
        hi(template class: member template)
    Member templates are defined in the same way as any other template,
including the tt(template <typename ...>) header.

    When converting our earlier tt(FBB::auto_ptr(Data const (&array)[Size]))
constructor into a member template we may use the template class'ss tt(Data)
type parameter, but must provide the member template with a non-type parameter
of its own. The constructor's inline implementation becomes:
        verb(
    template <unsigned Size>
    auto_ptr(Data const (&arr)[Size])
    :
        d_data(new Data[Size]),
        d_n(Size)
    {
        std::copy(arr, arr + Size, d_data);
    }
        )
    Member templates have the following characteristics:
    itemization(
    it() Normal i(access rules) apply: the constructor
can be used
by the general program to construct an tt(FBB::auto_ptr) object of a given
data type. As usual for template classes, the data type must be specified when
the object is constructed. To construct an tt(FBB::auto_ptr) object from the
array tt(int array[30]) we define:
    centt(FBB::auto_ptr<int> object(array);)
    it() Any member can be defined as a member template, not just a
constructor.
    it() Template members can be defined i(inline) or outside of their
containing class. When a member is defined below its class, the template class
    hi(template members: defined below their class) parameter list must
precede the template function parameter list of the template member. E.g.,
        verb(
    template <typename Data>
    template <unsigned Size>
    auto_ptr<Data>::auto_ptr(Data const (&arr)[Size])
    :
        d_data(new Data[Size]),
        d_n(Size)
    {
        std::cout << "fixed array\n";
        std::copy(arr, arr + Size, d_data);
    }
        )
    When defining a template member below its class
        itemization(
        it() The definition should be given inside its proper namespace
environment. The organization within files defining template classes within a
namespace should therefore be:
        verb(
    namespace SomeName
    {
        template <typename Type, ...>   // template class definition
        class ClassName
        {
            ...
        };

        template <typename Type, ...>   // non-inline member definition(s)
        ClassName<Type, ...>::member(...)
        {
            ...
        }
    }                                   // namespace closed
        )
        it() Two template announcements must be used: the template class's
template announcement is specified first, followed by the member template's
template announcement.
        it() The definition itself must specify the member template's
proper scope: the member template is defined as a member of the class
tt(FBB::auto_ptr), instantiated for the formal template parameter type
tt(Data). Since we're already inside the namespace tt(FBB), the function
header starts with tt(auto_ptr<Data>::auto_ptr).
        it() When member templates are defined below their classes, the formal
template parameter names in the declaration and implementation must be
identical.
        )
    )
    One little problem remains. When we're constructing an tt(FBB::auto_ptr)
object from a fixed-size array the above constructor is not used. Instead, the
constructor tt(FBB::auto_ptr<Data>::auto_ptr(Data *data)) is activated. As the
latter constructor is not a member template, it is considered a more
specialized version of a constructor of the class tt(FBB::auto_ptr) than the
former constructor. Since both constructors accept an array the compiler will
call tt(auto_ptr(Data *)) rather than tt(auto_ptr(Data const
(&array)[Size])). This little problem can be solved by simply changing the
constructor tt(auto_ptr(Data *data)) into a member template as well, in which
case its template type parameter should be changed into `tt(Data)'. The only
remaining subtlety is that template parameters of member templates may not
shadow
        hi(shadowing template parameters)
        hi(template class: shadowing template parameters)
    the template parameters of their class. Renaming tt(Data) into tt(Data2)
takes care of this subtlety. Here is the (inline) definition of the
tt(auto_ptr(Data *)) constructor, followed by an example in which both
constructors are actually used:
        verb(
    template <typename Data2>
    auto_ptr(Data2 *data)       // must have been dynamically allocated
    :
        d_data(data),
        d_n(0)
    {}
        )
    Calling both constructors in tt(main()):
        verb(
    int main()
    {
        int array[30];

        FBB::auto_ptr<int> ap(array);
        FBB::auto_ptr<int> ap2(new int[30]);

        return 0;
    }
        )
