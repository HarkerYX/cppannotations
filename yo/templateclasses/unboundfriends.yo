    When a friend is declared as an em(unbound) friend, it merely declares an
existing template to be its friend, no matter how it is instantiated. This may
be useful in situations where the friend should be able to
instantiate objects of template classes declaring the friend, allowing the
friend to access the instantiated object's private members.
Again, functions, classes and member functions may be declared as unbound
friends.

Here are  the syntactical conventions  declaring unbound friends:
    itemization(
        it() Declaring an unbound template function as a friend: any
instantiation of the template function may instantiate objects of the template
class and may access its private members. Assume the following
template function has been defined
        verb(
    template <typename Iterator, typename Class, typename Data>
    Class &ForEach(Iterator begin, Iterator end, Class &object,
                        void (Class::*member)(Data &));
        )

    This template function can be declared as an unbound friend in the
following template class tt(Vector2):
        verb(
    template <typename Type>
    class Vector2: public std::vector<std::vector<Type> >
    {
        template <typename Iterator, typename Class, typename Data>
        friend Class &ForEach(Iterator begin, Iterator end, Class &object,
                    void (Class::*member)(Data &));
        ...
    };
        )
    If the template function is defined inside some namespace, the namespace
must be mentioned as well. E.g., assuming that tt(ForEach()) is defined in the
namespace tt(FBB) its friend declaration becomes:
        verb(
    template <typename Iterator, typename Class, typename Data>
    friend Class &FBB::ForEach(Iterator begin, Iterator end, Class &object,
                    void (Class::*member)(Data &));
        )
    The following example illustrates the use of an unbound friend. The class
tt(Vector2) stores vectors of elements of template type parameter
tt(Type). Its tt(process()) member uses tt(ForEach()) to have its private
tt(rows()) member called, which in turn uses tt(ForEach()) to call its private
tt(columns()) member. Consequently, tt(Vector2) uses two instantiations of
tt(ForEach()), and therefore an unbound friend is appropriate here. It is
assumed that tt(Type) class objects can be inserted into tt(ostream) objects
(the definition of the tt(ForEach()) template function can be found in the
tt(cplusplus.yo.zip) archive at the tt(ftp.rug.nl) ftp-server). Here is the
program:
        verbinsert(VECTOR2)(concrete/examples/foreachdemo.cc)
    it() Analogously, a full template class may be declared as a friend. This
allows all instantiations of the friend's member functions to instantiate the
template declaring the friend class. In this case, the class declaring the
friend should offer useful functionality to different instantiations (i.e.,
using different arguments for its template parameters) of its friend
class. The syntactical convention is comparable to the convention used when
declaring an unbound friend template function:
        verb(
    template <typename Type>
    class PtrVector
    {
        template <typename Iterator, typename Class>
        friend class Wrapper;      // unbound friend class
    };
        )
    All members of the template class tt(Wrapper) may now instantiate
tt(PtrVector)s using any actual type for its tt(Type) template parameter, at
the same time allowing tt(Wrapper)'s instantiation to access all of
tt(PtrVector)'s private members.
    it() When only some members of a template class need access to the private
members of another template class (e.g., the other template class has private
constructors, and only some members of the first template class
need to instantiate objects of the second template class), then the latter
template class may declare only those members of the former template class
requiring access to its private members as its friends. Again, the friend
class's interface may be left unspecified. However, the compiler must be
informed that the friend member's class is indeed a class. A forward
declaration of that class must therefore be given as well. In the following
example tt(PtrVector) declares tt(Wrapper::begin()) as its friend. Note the
forward declaration of the class tt(Wrapper):
        verb(
    template <typename Iterator>
    class Wrapper;

    template <typename Type>
    class PtrVector
    {
        template <typename Iterator> friend
            PtrVector<Type> Wrapper<Iterator>::begin(Iterator const &t1);
        ...
    };
        )
    )
