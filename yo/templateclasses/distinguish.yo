    Since a template type name may refer to any type, a template's type name
might also refer to a template or a class itself. Let's assume a template
class tt(Handler) defines a tt(typename Container) as its type parameter, and
a data member storing the container's tt(begin()) iterator. Furthermore, the
class template tt(Handler) has a constructor accepting any container
supporting a tt(begin()) member. The skeleton of our
class tt(Handler) could then be:
        verb(
    template <typename Container>
    class Handler
    {
        Container::const_iterator d_it;

        public:
            Handler(Container const &container)
            :
                d_it(container.begin())
            {}
    };
        )
    What were the considerations we had in mind when designing this class?
    itemization(
    it() The typename tt(Container) represents any container supporting
iterators.
    it() The container presumably supports a member tt(begin()). The
initialization tt(d_it(container.begin())) clearly depends on the
template's type parameter, so it's only checked for basic syntactical
correctness.
    it() Likewise, the container presumably supports a type
tt(const_iterator), defined in the class tt(Container). Since tt(container) is
a tt(const) reference, the iterator returned by tt(begin()) is a
tt(const_iterator) rather than a plain tt(iterator).
    )
    Now, when instantiating a tt(Handler) using the following tt(main())
function we run into a compilation error:
        verb(
    #include "handler.h"
    #include <vector>
    using namespace std;

    int main()
    {
        vector<int> vi;
        Handler<vector<int> > ph(vi);
    }
    /*
        Reported error:

    handler.h:4: error: syntax error before `;' token
    */
        )
    Apparently the line
        centt(Container::const_iterator d_it;)
    in the tt(Handler) class causes a problem. The problem is the following:
when using template type parameters, a plain syntax check allows the compiler
to decide that `tt(container)' refers to a tt(Container) object. Such a
tt(Container) might very well support a tt(begin()) member, hence
tt(container.begin()) is syntactically correct. However, for a actual
tt(Container) type that member tt(begin()) might not have been implemented. Of
course, whether or not tt(begin()) has in fact been implemented will only be
known by the time tt(Container)'s actual type has been specified.

    On the other hand, note that the compiler is unable to determine what a
tt(Container::const_iterator) is. The compiler takes the easy way out, and
assumes tt(const_iterator) is a member of the as yet mysterious
tt(Container). Therefore, a plain syntax check clearly fails, as the statement
        centt(Container::const_iterator d_it;)
    is always syntactically wrong when tt(const_iterator) is a member or
enum-value of tt(Container). Of course, em(we) know better, since we have a
type that is nested under the class tt(Container) in mind. The compiler,
however, doesn't know that and before it has parsed the complete definition,
it has already read tt(Container::const_iterator). At that point the compiler
has already made up its mind, assuming that tt(Container::const_iterator) will
be a member, rather than a type.

    That the compiler indeed assumes tt(X::a) is a member tt(a) of the class
tt(X) is illustrated by the error message we get when we try to compile
tt(main()) using the following implementation of tt(Handler)'s constructor:
        verb(
    Handler(Container const &container)
    :
        d_it(container.begin())
    {
        size_t x = Container::ios_end;
    }
    /*
        Reported error:

        error: `ios_end' is not a member of type `std::vector<int,
                std::allocator<int> >'
    */
        )
    In cases like these, where the intent is to refer to a em(type) defined in
(or depending on) a class template like tt(Container), this must explicitly be
indicated to the
    hi(class template: typename overrules member)
compiler, using the tt(typename) keyword. Here is the tt(Handler) class once
again, now using tt(typename):
        verb(
    template <typename Container>
    class Handler
    {
        typename Container::const_iterator d_it;
        public:
            Handler(Container const &container);
    };

    template <typename Container>
    inline Handler<Container>::Handler(Container const &container)
    :
        d_it(container.begin())
    {}
        )
    Now tt(main()) will compile correctly. The tt(typename) keyword may also
be required when specifying the proper return types of class template member
functions returning values of nested types defined within the template
class. Section ref(RETURNNESTED) provides an example of this situation.
