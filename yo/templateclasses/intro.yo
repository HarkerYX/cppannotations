    Like function templates, templates can be constructed for complete
classes. A i(template class) can be considered when the class should be able
to handle different types of data. Template classes are frequently used in
bf(C++): chapter ref(Containers) covered general data structures like
tt(vector, stack) and tt(queue), defined as em(template classes). With
template classes, the hi(algorithm) algorithms and the data on which the
algorithms operate are completely separated from each other. To use a
particular i(data structure), operating on a particular data type, only the
i(data type) needs to be specified when the template class object is defined
or declared, e.g., tt(stack<int> iStack).

Below the construction of template classes is discussed. In a sense, template
classes compete with
        i(object oriented programming)
    (cf. chapter ref(POLYMORPHISM)), where a mechanism somewhat similar to
templates is seen. Polymorphism
        hi(polymorphism)
    allows the programmer to postpone the definitions of algorithms, by
deriving classes from a i(base class) in which the algorithm is only partially
implemented, while the data upon which the algorithms operate may first be
defined in i(derived class)es, together with member functions that were
defined as
    i(pure virtual functions) in the base class to handle the data. On the
other hand, templates allow the programmer to postpone the specification of
the data upon which the algorithms operate. This is most clearly seen with the
abstract containers, completely specifying the algorithms but at the same time
leaving the data type on which the algorithms operate completely unspecified.

Generally, template classes are easier to use. It is certainly easier to write
tt(stack<int> istack) to create a stack of tt(ints) than to derive a new
class tt(Istack: public stack) and to implement all necessary member functions
to be able to create a similar stack of tt(ints) using object oriented
programming. On the other hand, for each different type that is used with a
template class the complete class is reinstantiated, whereas in the context of
object oriented programming the derived classes em(use), rather than em(copy),
the functions that are already available in the base class (but see also
section ref(DERIVEDTEMPCLASS)).
